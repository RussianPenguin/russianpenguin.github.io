<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta name="yandex-verification" content="551ffc5ae1433df6" />
    
    <meta charset="UTF-8">

<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Несколько советов по оптимизации приложений на Angular JS | Чтобы не забыть</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Несколько советов по оптимизации приложений на Angular JS" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Что нам потребуется. AngularJS Версия &lt; 1.3 В версии 1.3 появились существенные отличия. Включая однонаправленный биндинг - :: (два двоеточия), но она несовместима с bindonce. Хотя по скорости ничем не уступает оптимизированному варианту. Если вы используете &gt;= 1.3, то применяйте готовый однонаправленный биндинг вместо bo-* Bindonce url: https://github.com/Pasvaz/bindonce Эта библиотека позволяет делать однонаправленный биндинг данных в шаблоны. Если вам не требуется, чтобы какая-то переменная после своего отображения меняла значение (т.е. она не будет его менять в процессе работы), то это однозначно для вас. Например у нас есть список книг, который приходит с сервера и обновляется целиком (опять же с сервера). Что мы делаем в коде \&lt;div ng-repeat=&quot;book in books&quot;\&gt;\&lt;span\&gt;\&lt;/span\&gt;\&lt;div\&gt; Имя книги не меняется и мы можем записать так \&lt;div ng-repeat=&quot;book in books&quot;\&gt;\&lt;span bo-text=&quot;book.name&quot;\&gt;\&lt;/span\&gt;\&lt;div\&gt; Так как при перезагрузке книг список books будет изменен полностью, то дерево будет перестроено заново и нам не нужно никак заботиться о том, что имя изменится. Однако, если вы используете sly-repeat (ниже), то его нельзя сочетать с bindonce из-за агрессивного кеширования дерева дом этим самым слайрепитом. Scalyr url: https://github.com/scalyr/angular post: http://blog.scalyr.com/2013/10/31/angularjs-1200ms-to-35ms/ Эта библиотека позволит вам минимизировать количество одновременно работающих вотчеров путем отключения ненужных. А так же реализовать умный ng-repeat с кешированием созданных dom-элементов (который, увы, не сильно дружит с bindonce. т.е. не дружит вовсе). Оптимизации Много скрытых элементов на странице Это одна из ключевых оптимизаций для проекта. Так как нам часто приходится скрывать/показывать разные элементы. Представим, что у нас есть какой-то код типа нижеследующего. \&lt;div ng-show=&quot;condition&quot;\&gt;\&lt;!-- а тут много разных строчек с данными, которые выводятся на базе данных из ангуляра --\&gt;\&lt;/div\&gt; Если не предпринять дополнительных действий, то все то, что написано внутри скрытого дива будет выполняться (!), а это лишние такты процессора и нервные подергивания пользователя. Что же мы можем сделать? На помощь нам приходит sly-show+sly-prevent-evaluation-when-hidden. Эта убойная комбинация не будет запускать интерпретацию скрытых элементов. \&lt;div sly-show=&quot;condition&quot; sly-prevent-evaluation-when-hidden\&gt;\&lt;!-- а тут много разных строчек с данными, которые выводятся на базе данных из ангуляра --\&gt;\&lt;/div\&gt; Переписав код таким образом мы получим тот самый профит: снижение нагрузки на клиент-сайд. Но стоит заметить одну особенность директивы: она в своем решении интерпретировать или нет вложенный код опирается на наличие класса ng-hide. При инициализации приложения или перерисовке элементов этого класса нет. Поэтому мы можем увидеть что-то вроде этого: Причина проста: у элементов при инициализации еще нет класса ng-hide. Он появится только после того, как отработают нужны контроллеры, а значит, что отрисовка элемента с нуля всегда будет отрисовывать и интерпретировать все скрываемые элементы (даже если они действительно скрыты). Решение проблемы: принудительно добавить класс ng-hide всем элементам, которые находятся под связкой sly-show+sly-prevent-evaluation-when-hidden. \&lt;div class=&quot;ng-hide&quot;\&gt;\&lt;!-- а тут много разных строчек с данными, которые выводятся на базе данных из ангуляра --\&gt;\&lt;/div\&gt; На этом оптимизация неиспользуемого кода закончена. Оптимизация биндингов Под этим подразумевается однократное добавление в шаблон переменной. Как в примере bindonce с книгами (выше) нам может не требоваться функционал двунаправленного отображения. Поэтому все подобные участки мы заменяем однонаправленным биндингом. -\&gt; \&lt;div bo-text=”var”\&gt;\&lt;/div\&gt; Путь оптимизации: вместо элемента создается контейнер, на который выполняется отображение текста элемента. Так как в биндванс не существует шаблонной конструкции для биндинга. Естественно, что там может быть любой тег и не обязательно div. Самое главное - наличие контейнера. ng-href=&quot;text&quot; -\&gt; bo-href=&quot;’text’ + var&quot; А так мы оптимизировали ссылки. Важно заметить, что ng-* и bo-* работают с биндингами различным образом: если первый работает по внутриангуляровским правилам интепретации, то второй просто выполняет .eval() на строку. Поэтому в bo-* мы работаем с обычными строками и переменными. Аналогичным образом работаем и с другими атрибутами. Если есть аналог биндинга. Если аналога нет, то используем конструкцию bo-attr-&lt;имя кастомного атрибута&gt; \&lt;div bo-attr bo-attr-isbn=&quot;’’&quot;\&gt;\&lt;/div\&gt; Здесь кроется еще одна важная особенность обработки атрибутов библиотекой: они рассматриваются как строки. И если в атрибуте текст, что его надо представить в виде текста (то же характерно для любого юиндига bo-*). Мы привыкли чаще всего работать с числами, но не стоит забывать, что есть еще буквы. Поэтому если не уверены в содержимом переменной - пишите строковое предствление: ‘’, а не var. Вложенность элементов На картинке профайлера (выше) вы можете увидеть гребенку из кучи вложенных вызовов функций. Если мы посмотрим на эти вывовы под микроскопом отладчиком, то увидим, что это рекурсивный обход дерева dom. Чем меньше у вас уровней вложенности, тем лучше. Особенно это касается кода, который расположен в циклах. Так что старайтесь сократить вложенности. Дополнительная оптимизация при обработке скрытых элементов У sly-prevent-evaluation-when-hidden есть одна большая проблема: она опирается только на наличие класса ng-hide, что не совсем уместно если видимость элемента контролируется каким-то другим классом. В таком случае можно (вообще нужно всегда) использовать следующее расширение директивы (подключаем после подключения scalyr). /\*\* \* Extended version of slyPreventEvaluationWhenHidden from scalyr. \* This version prevent evaluation not only when element has class ng-hide. \* If element is hidden with &quot;display: none&quot; evaluation is prevented. \*/ angular.module(&#39;sly&#39;) .directive(&#39;slyPreventEvaluationWhenHidden&#39;, function () { return { restrict: &#39;A&#39;, // We create a new scope just because it helps segment the gated watchers // from the parent scope. Unclear if this is that important for perf. scope: true, compile: function compile(tElement, tAttrs) { return { // We need a separate pre-link function because we want to modify the scope before any of the // children are passed it. pre: function preLink(scope, element, attrs) { scope.$addWatcherGate(function hiddenChecker() { // Should only return true if the element is not hidden. return !element.hasClass(&#39;ng-hide&#39;) &amp;&amp; element.is(&quot;:visible&quot;) ; }, function hiddenDecider(watchExpression, listener, equality, directiveName) { // Make an exception for slyShow.. do not gate its watcher. if (isDefined(directiveName) &amp;&amp; (directiveName == &#39;slyShow&#39;)) return false; return true; }); }, }; }, }; });" />
<meta property="og:description" content="Что нам потребуется. AngularJS Версия &lt; 1.3 В версии 1.3 появились существенные отличия. Включая однонаправленный биндинг - :: (два двоеточия), но она несовместима с bindonce. Хотя по скорости ничем не уступает оптимизированному варианту. Если вы используете &gt;= 1.3, то применяйте готовый однонаправленный биндинг вместо bo-* Bindonce url: https://github.com/Pasvaz/bindonce Эта библиотека позволяет делать однонаправленный биндинг данных в шаблоны. Если вам не требуется, чтобы какая-то переменная после своего отображения меняла значение (т.е. она не будет его менять в процессе работы), то это однозначно для вас. Например у нас есть список книг, который приходит с сервера и обновляется целиком (опять же с сервера). Что мы делаем в коде \&lt;div ng-repeat=&quot;book in books&quot;\&gt;\&lt;span\&gt;\&lt;/span\&gt;\&lt;div\&gt; Имя книги не меняется и мы можем записать так \&lt;div ng-repeat=&quot;book in books&quot;\&gt;\&lt;span bo-text=&quot;book.name&quot;\&gt;\&lt;/span\&gt;\&lt;div\&gt; Так как при перезагрузке книг список books будет изменен полностью, то дерево будет перестроено заново и нам не нужно никак заботиться о том, что имя изменится. Однако, если вы используете sly-repeat (ниже), то его нельзя сочетать с bindonce из-за агрессивного кеширования дерева дом этим самым слайрепитом. Scalyr url: https://github.com/scalyr/angular post: http://blog.scalyr.com/2013/10/31/angularjs-1200ms-to-35ms/ Эта библиотека позволит вам минимизировать количество одновременно работающих вотчеров путем отключения ненужных. А так же реализовать умный ng-repeat с кешированием созданных dom-элементов (который, увы, не сильно дружит с bindonce. т.е. не дружит вовсе). Оптимизации Много скрытых элементов на странице Это одна из ключевых оптимизаций для проекта. Так как нам часто приходится скрывать/показывать разные элементы. Представим, что у нас есть какой-то код типа нижеследующего. \&lt;div ng-show=&quot;condition&quot;\&gt;\&lt;!-- а тут много разных строчек с данными, которые выводятся на базе данных из ангуляра --\&gt;\&lt;/div\&gt; Если не предпринять дополнительных действий, то все то, что написано внутри скрытого дива будет выполняться (!), а это лишние такты процессора и нервные подергивания пользователя. Что же мы можем сделать? На помощь нам приходит sly-show+sly-prevent-evaluation-when-hidden. Эта убойная комбинация не будет запускать интерпретацию скрытых элементов. \&lt;div sly-show=&quot;condition&quot; sly-prevent-evaluation-when-hidden\&gt;\&lt;!-- а тут много разных строчек с данными, которые выводятся на базе данных из ангуляра --\&gt;\&lt;/div\&gt; Переписав код таким образом мы получим тот самый профит: снижение нагрузки на клиент-сайд. Но стоит заметить одну особенность директивы: она в своем решении интерпретировать или нет вложенный код опирается на наличие класса ng-hide. При инициализации приложения или перерисовке элементов этого класса нет. Поэтому мы можем увидеть что-то вроде этого: Причина проста: у элементов при инициализации еще нет класса ng-hide. Он появится только после того, как отработают нужны контроллеры, а значит, что отрисовка элемента с нуля всегда будет отрисовывать и интерпретировать все скрываемые элементы (даже если они действительно скрыты). Решение проблемы: принудительно добавить класс ng-hide всем элементам, которые находятся под связкой sly-show+sly-prevent-evaluation-when-hidden. \&lt;div class=&quot;ng-hide&quot;\&gt;\&lt;!-- а тут много разных строчек с данными, которые выводятся на базе данных из ангуляра --\&gt;\&lt;/div\&gt; На этом оптимизация неиспользуемого кода закончена. Оптимизация биндингов Под этим подразумевается однократное добавление в шаблон переменной. Как в примере bindonce с книгами (выше) нам может не требоваться функционал двунаправленного отображения. Поэтому все подобные участки мы заменяем однонаправленным биндингом. -\&gt; \&lt;div bo-text=”var”\&gt;\&lt;/div\&gt; Путь оптимизации: вместо элемента создается контейнер, на который выполняется отображение текста элемента. Так как в биндванс не существует шаблонной конструкции для биндинга. Естественно, что там может быть любой тег и не обязательно div. Самое главное - наличие контейнера. ng-href=&quot;text&quot; -\&gt; bo-href=&quot;’text’ + var&quot; А так мы оптимизировали ссылки. Важно заметить, что ng-* и bo-* работают с биндингами различным образом: если первый работает по внутриангуляровским правилам интепретации, то второй просто выполняет .eval() на строку. Поэтому в bo-* мы работаем с обычными строками и переменными. Аналогичным образом работаем и с другими атрибутами. Если есть аналог биндинга. Если аналога нет, то используем конструкцию bo-attr-&lt;имя кастомного атрибута&gt; \&lt;div bo-attr bo-attr-isbn=&quot;’’&quot;\&gt;\&lt;/div\&gt; Здесь кроется еще одна важная особенность обработки атрибутов библиотекой: они рассматриваются как строки. И если в атрибуте текст, что его надо представить в виде текста (то же характерно для любого юиндига bo-*). Мы привыкли чаще всего работать с числами, но не стоит забывать, что есть еще буквы. Поэтому если не уверены в содержимом переменной - пишите строковое предствление: ‘’, а не var. Вложенность элементов На картинке профайлера (выше) вы можете увидеть гребенку из кучи вложенных вызовов функций. Если мы посмотрим на эти вывовы под микроскопом отладчиком, то увидим, что это рекурсивный обход дерева dom. Чем меньше у вас уровней вложенности, тем лучше. Особенно это касается кода, который расположен в циклах. Так что старайтесь сократить вложенности. Дополнительная оптимизация при обработке скрытых элементов У sly-prevent-evaluation-when-hidden есть одна большая проблема: она опирается только на наличие класса ng-hide, что не совсем уместно если видимость элемента контролируется каким-то другим классом. В таком случае можно (вообще нужно всегда) использовать следующее расширение директивы (подключаем после подключения scalyr). /\*\* \* Extended version of slyPreventEvaluationWhenHidden from scalyr. \* This version prevent evaluation not only when element has class ng-hide. \* If element is hidden with &quot;display: none&quot; evaluation is prevented. \*/ angular.module(&#39;sly&#39;) .directive(&#39;slyPreventEvaluationWhenHidden&#39;, function () { return { restrict: &#39;A&#39;, // We create a new scope just because it helps segment the gated watchers // from the parent scope. Unclear if this is that important for perf. scope: true, compile: function compile(tElement, tAttrs) { return { // We need a separate pre-link function because we want to modify the scope before any of the // children are passed it. pre: function preLink(scope, element, attrs) { scope.$addWatcherGate(function hiddenChecker() { // Should only return true if the element is not hidden. return !element.hasClass(&#39;ng-hide&#39;) &amp;&amp; element.is(&quot;:visible&quot;) ; }, function hiddenDecider(watchExpression, listener, equality, directiveName) { // Make an exception for slyShow.. do not gate its watcher. if (isDefined(directiveName) &amp;&amp; (directiveName == &#39;slyShow&#39;)) return false; return true; }); }, }; }, }; });" />
<link rel="canonical" href="http://localhost:4000/2014/10/20/%D0%BD%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE-%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%B2-%D0%BF%D0%BE-%D0%BE%D0%BF%D1%82%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%BF%D1%80%D0%B8/" />
<meta property="og:url" content="http://localhost:4000/2014/10/20/%D0%BD%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE-%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%B2-%D0%BF%D0%BE-%D0%BE%D0%BF%D1%82%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%BF%D1%80%D0%B8/" />
<meta property="og:site_name" content="Чтобы не забыть" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2014-10-20T21:14:53+04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Несколько советов по оптимизации приложений на Angular JS" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2014/10/20/%D0%BD%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE-%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%B2-%D0%BF%D0%BE-%D0%BE%D0%BF%D1%82%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%BF%D1%80%D0%B8/","description":"Что нам потребуется. AngularJS Версия &lt; 1.3 В версии 1.3 появились существенные отличия. Включая однонаправленный биндинг - :: (два двоеточия), но она несовместима с bindonce. Хотя по скорости ничем не уступает оптимизированному варианту. Если вы используете &gt;= 1.3, то применяйте готовый однонаправленный биндинг вместо bo-* Bindonce url: https://github.com/Pasvaz/bindonce Эта библиотека позволяет делать однонаправленный биндинг данных в шаблоны. Если вам не требуется, чтобы какая-то переменная после своего отображения меняла значение (т.е. она не будет его менять в процессе работы), то это однозначно для вас. Например у нас есть список книг, который приходит с сервера и обновляется целиком (опять же с сервера). Что мы делаем в коде \\&lt;div ng-repeat=&quot;book in books&quot;\\&gt;\\&lt;span\\&gt;\\&lt;/span\\&gt;\\&lt;div\\&gt; Имя книги не меняется и мы можем записать так \\&lt;div ng-repeat=&quot;book in books&quot;\\&gt;\\&lt;span bo-text=&quot;book.name&quot;\\&gt;\\&lt;/span\\&gt;\\&lt;div\\&gt; Так как при перезагрузке книг список books будет изменен полностью, то дерево будет перестроено заново и нам не нужно никак заботиться о том, что имя изменится. Однако, если вы используете sly-repeat (ниже), то его нельзя сочетать с bindonce из-за агрессивного кеширования дерева дом этим самым слайрепитом. Scalyr url: https://github.com/scalyr/angular post: http://blog.scalyr.com/2013/10/31/angularjs-1200ms-to-35ms/ Эта библиотека позволит вам минимизировать количество одновременно работающих вотчеров путем отключения ненужных. А так же реализовать умный ng-repeat с кешированием созданных dom-элементов (который, увы, не сильно дружит с bindonce. т.е. не дружит вовсе). Оптимизации Много скрытых элементов на странице Это одна из ключевых оптимизаций для проекта. Так как нам часто приходится скрывать/показывать разные элементы. Представим, что у нас есть какой-то код типа нижеследующего. \\&lt;div ng-show=&quot;condition&quot;\\&gt;\\&lt;!-- а тут много разных строчек с данными, которые выводятся на базе данных из ангуляра --\\&gt;\\&lt;/div\\&gt; Если не предпринять дополнительных действий, то все то, что написано внутри скрытого дива будет выполняться (!), а это лишние такты процессора и нервные подергивания пользователя. Что же мы можем сделать? На помощь нам приходит sly-show+sly-prevent-evaluation-when-hidden. Эта убойная комбинация не будет запускать интерпретацию скрытых элементов. \\&lt;div sly-show=&quot;condition&quot; sly-prevent-evaluation-when-hidden\\&gt;\\&lt;!-- а тут много разных строчек с данными, которые выводятся на базе данных из ангуляра --\\&gt;\\&lt;/div\\&gt; Переписав код таким образом мы получим тот самый профит: снижение нагрузки на клиент-сайд. Но стоит заметить одну особенность директивы: она в своем решении интерпретировать или нет вложенный код опирается на наличие класса ng-hide. При инициализации приложения или перерисовке элементов этого класса нет. Поэтому мы можем увидеть что-то вроде этого: Причина проста: у элементов при инициализации еще нет класса ng-hide. Он появится только после того, как отработают нужны контроллеры, а значит, что отрисовка элемента с нуля всегда будет отрисовывать и интерпретировать все скрываемые элементы (даже если они действительно скрыты). Решение проблемы: принудительно добавить класс ng-hide всем элементам, которые находятся под связкой sly-show+sly-prevent-evaluation-when-hidden. \\&lt;div class=&quot;ng-hide&quot;\\&gt;\\&lt;!-- а тут много разных строчек с данными, которые выводятся на базе данных из ангуляра --\\&gt;\\&lt;/div\\&gt; На этом оптимизация неиспользуемого кода закончена. Оптимизация биндингов Под этим подразумевается однократное добавление в шаблон переменной. Как в примере bindonce с книгами (выше) нам может не требоваться функционал двунаправленного отображения. Поэтому все подобные участки мы заменяем однонаправленным биндингом. -\\&gt; \\&lt;div bo-text=”var”\\&gt;\\&lt;/div\\&gt; Путь оптимизации: вместо элемента создается контейнер, на который выполняется отображение текста элемента. Так как в биндванс не существует шаблонной конструкции для биндинга. Естественно, что там может быть любой тег и не обязательно div. Самое главное - наличие контейнера. ng-href=&quot;text&quot; -\\&gt; bo-href=&quot;’text’ + var&quot; А так мы оптимизировали ссылки. Важно заметить, что ng-* и bo-* работают с биндингами различным образом: если первый работает по внутриангуляровским правилам интепретации, то второй просто выполняет .eval() на строку. Поэтому в bo-* мы работаем с обычными строками и переменными. Аналогичным образом работаем и с другими атрибутами. Если есть аналог биндинга. Если аналога нет, то используем конструкцию bo-attr-&lt;имя кастомного атрибута&gt; \\&lt;div bo-attr bo-attr-isbn=&quot;’’&quot;\\&gt;\\&lt;/div\\&gt; Здесь кроется еще одна важная особенность обработки атрибутов библиотекой: они рассматриваются как строки. И если в атрибуте текст, что его надо представить в виде текста (то же характерно для любого юиндига bo-*). Мы привыкли чаще всего работать с числами, но не стоит забывать, что есть еще буквы. Поэтому если не уверены в содержимом переменной - пишите строковое предствление: ‘’, а не var. Вложенность элементов На картинке профайлера (выше) вы можете увидеть гребенку из кучи вложенных вызовов функций. Если мы посмотрим на эти вывовы под микроскопом отладчиком, то увидим, что это рекурсивный обход дерева dom. Чем меньше у вас уровней вложенности, тем лучше. Особенно это касается кода, который расположен в циклах. Так что старайтесь сократить вложенности. Дополнительная оптимизация при обработке скрытых элементов У sly-prevent-evaluation-when-hidden есть одна большая проблема: она опирается только на наличие класса ng-hide, что не совсем уместно если видимость элемента контролируется каким-то другим классом. В таком случае можно (вообще нужно всегда) использовать следующее расширение директивы (подключаем после подключения scalyr). /\\*\\* \\* Extended version of slyPreventEvaluationWhenHidden from scalyr. \\* This version prevent evaluation not only when element has class ng-hide. \\* If element is hidden with &quot;display: none&quot; evaluation is prevented. \\*/ angular.module(&#39;sly&#39;) .directive(&#39;slyPreventEvaluationWhenHidden&#39;, function () { return { restrict: &#39;A&#39;, // We create a new scope just because it helps segment the gated watchers // from the parent scope. Unclear if this is that important for perf. scope: true, compile: function compile(tElement, tAttrs) { return { // We need a separate pre-link function because we want to modify the scope before any of the // children are passed it. pre: function preLink(scope, element, attrs) { scope.$addWatcherGate(function hiddenChecker() { // Should only return true if the element is not hidden. return !element.hasClass(&#39;ng-hide&#39;) &amp;&amp; element.is(&quot;:visible&quot;) ; }, function hiddenDecider(watchExpression, listener, equality, directiveName) { // Make an exception for slyShow.. do not gate its watcher. if (isDefined(directiveName) &amp;&amp; (directiveName == &#39;slyShow&#39;)) return false; return true; }); }, }; }, }; });","headline":"Несколько советов по оптимизации приложений на Angular JS","dateModified":"2014-10-20T21:14:53+04:00","datePublished":"2014-10-20T21:14:53+04:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2014/10/20/%D0%BD%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE-%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%B2-%D0%BF%D0%BE-%D0%BE%D0%BF%D1%82%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%BF%D1%80%D0%B8/"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="/assets/css/style.css?v=d85e6f1917405784d52928d499ab3e51b4bffcc9">
  </head>
  <body>
    <header class="page-header" role="banner">
      <h1 class="project-name">Несколько советов по оптимизации приложений на Angular JS</h1>
      <h2 class="project-tagline">Записная книжка рассеянного [в пространстве и времени] программиста</h2>
      
        <a href="https://github.com/RussianPenguin/russianpenguin.github.io" class="btn">View on GitHub</a>
      
      
    </header>

    <main id="content" class="main-content" role="main">
      <h1>Несколько советов по оптимизации приложений на Angular JS</h1>
<p>20 Oct 2014</p>

<h2 id="что-нам-потребуется">Что нам потребуется.</h2>

<h3 id="angularjs">AngularJS</h3>

<p>Версия &lt; 1.3</p>

<p>В версии 1.3 появились существенные отличия. Включая однонаправленный биндинг - :: (два двоеточия), но она несовместима с bindonce.</p>

<p>Хотя по скорости ничем не уступает оптимизированному варианту. Если вы используете &gt;= 1.3, то применяйте готовый однонаправленный биндинг вместо bo-*</p>

<h3 id="bindonce">Bindonce</h3>

<p>url: <a href="https://github.com/Pasvaz/bindonce" title="Bindonce">https://github.com/Pasvaz/bindonce</a></p>

<p>Эта библиотека позволяет делать однонаправленный биндинг данных в шаблоны.<br />
Если вам не требуется, чтобы какая-то переменная после своего отображения меняла значение (т.е. она не будет его менять в процессе работы), то это однозначно для вас.</p>

<p>Например у нас есть список книг, который приходит с сервера и обновляется целиком (опять же с сервера).<br />
Что мы делаем в коде</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\<span class="nt">&lt;div</span> <span class="na">ng-repeat=</span><span class="s">"book in books"</span><span class="err">\</span><span class="nt">&gt;</span>\<span class="nt">&lt;span</span><span class="err">\</span><span class="nt">&gt;</span>\<span class="nt">&lt;/span</span><span class="err">\</span><span class="nt">&gt;</span>\<span class="nt">&lt;div</span><span class="err">\</span><span class="nt">&gt;</span>
</code></pre></div></div>

<p>Имя книги не меняется и мы можем записать так</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\<span class="nt">&lt;div</span> <span class="na">ng-repeat=</span><span class="s">"book in books"</span><span class="err">\</span><span class="nt">&gt;</span>\<span class="nt">&lt;span</span> <span class="na">bo-text=</span><span class="s">"book.name"</span><span class="err">\</span><span class="nt">&gt;</span>\<span class="nt">&lt;/span</span><span class="err">\</span><span class="nt">&gt;</span>\<span class="nt">&lt;div</span><span class="err">\</span><span class="nt">&gt;</span>
</code></pre></div></div>

<p>Так как при перезагрузке книг список books будет изменен полностью, то дерево будет перестроено заново и нам не нужно никак заботиться о том, что имя изменится.</p>

<p>Однако, если вы используете sly-repeat (ниже), то его нельзя сочетать с bindonce из-за агрессивного кеширования дерева дом этим самым слайрепитом.</p>

<h3 id="scalyr">Scalyr</h3>

<p>url: <a href="https://github.com/scalyr/angular" title="Scalyr">https://github.com/scalyr/angular</a></p>

<p>post: <a href="http://blog.scalyr.com/2013/10/31/angularjs-1200ms-to-35ms/" title="Blogpost about scalyr">http://blog.scalyr.com/2013/10/31/angularjs-1200ms-to-35ms/</a></p>

<p>Эта библиотека позволит вам минимизировать количество одновременно работающих вотчеров путем отключения ненужных. А так же реализовать умный ng-repeat с кешированием созданных dom-элементов (который, увы, не сильно дружит с bindonce. т.е. не дружит вовсе).</p>

<h2 id="оптимизации">Оптимизации</h2>

<h3 id="много-скрытых-элементов-на-странице">Много скрытых элементов на странице</h3>

<p>Это одна из ключевых оптимизаций для проекта. Так как нам часто приходится скрывать/показывать разные элементы.</p>

<p>Представим, что у нас есть какой-то код типа нижеследующего.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\<span class="nt">&lt;div</span> <span class="na">ng-show=</span><span class="s">"condition"</span><span class="err">\</span><span class="nt">&gt;</span>\<span class="c">&lt;!-- а тут много разных строчек с данными, которые выводятся на базе данных из ангуляра --\&gt;\&lt;/div\&gt;
</span></code></pre></div></div>

<p>Если не предпринять дополнительных действий, то все то, что написано внутри скрытого дива будет выполняться (!), а это лишние такты процессора и нервные подергивания пользователя.</p>

<p>Что же мы можем сделать?</p>

<p>На помощь нам приходит sly-show+sly-prevent-evaluation-when-hidden. Эта убойная комбинация не будет запускать интерпретацию скрытых элементов.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\<span class="nt">&lt;div</span> <span class="na">sly-show=</span><span class="s">"condition"</span> <span class="na">sly-prevent-evaluation-when-hidden</span><span class="err">\</span><span class="nt">&gt;</span>\<span class="c">&lt;!-- а тут много разных строчек с данными, которые выводятся на базе данных из ангуляра --\&gt;\&lt;/div\&gt;
</span></code></pre></div></div>

<p>Переписав код таким образом мы получим тот самый профит: снижение нагрузки на клиент-сайд.</p>

<p>Но стоит заметить одну особенность директивы: она в своем решении интерпретировать или нет вложенный код опирается на наличие класса ng-hide. При инициализации приложения или перерисовке элементов этого класса нет. Поэтому мы можем увидеть что-то вроде этого:</p>

<p><a href="https://russianpenguin.files.wordpress.com/2014/10/d0b2d18bd0b4d0b5d0bbd0b5d0bdd0b8d0b5_092.png"><img src="/assets/images/2014/10/d0b2d18bd0b4d0b5d0bbd0b5d0bdd0b8d0b5_092.png?w=300" alt="Trace angular application" /></a></p>

<p>Причина проста: у элементов при инициализации еще нет класса ng-hide. Он появится только после того, как отработают нужны контроллеры, а значит, что отрисовка элемента с нуля всегда будет отрисовывать и интерпретировать все скрываемые элементы (даже если они действительно скрыты).</p>

<p>Решение проблемы: принудительно добавить класс ng-hide всем элементам, которые находятся под связкой sly-show+sly-prevent-evaluation-when-hidden.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\<span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"ng-hide"</span><span class="err">\</span><span class="nt">&gt;</span>\<span class="c">&lt;!-- а тут много разных строчек с данными, которые выводятся на базе данных из ангуляра --\&gt;\&lt;/div\&gt;
</span></code></pre></div></div>

<p>На этом оптимизация неиспользуемого кода закончена.</p>

<h3 id="оптимизация-биндингов">Оптимизация биндингов</h3>

<p>Под этим подразумевается однократное добавление в шаблон переменной.</p>

<p>Как в примере bindonce с книгами (выше) нам может не требоваться функционал двунаправленного отображения.</p>

<p>Поэтому все подобные участки мы заменяем однонаправленным биндингом.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> -\&gt; \&lt;div bo-text=”var”\&gt;\&lt;/div\&gt;
</code></pre></div></div>

<p>Путь оптимизации: вместо элемента создается контейнер, на который выполняется отображение текста элемента. Так как в биндванс не существует шаблонной конструкции для биндинга. Естественно, что там может быть любой тег и не обязательно div. Самое главное - наличие контейнера.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ng-href="text" -\&gt; bo-href="’text’ + var"
</code></pre></div></div>

<p>А так мы оптимизировали ссылки.<br />
Важно заметить, что ng-* и bo-* работают с биндингами различным образом: если первый работает по внутриангуляровским правилам интепретации, то второй просто выполняет .eval() на строку. Поэтому в bo-* мы работаем с обычными строками и переменными.</p>

<p>Аналогичным образом работаем и с другими атрибутами. Если есть аналог биндинга.</p>

<p>Если аналога нет, то используем конструкцию bo-attr-&lt;имя кастомного атрибута&gt;</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\<span class="nt">&lt;div</span> <span class="na">bo-attr</span> <span class="na">bo-attr-isbn=</span><span class="s">"’’"</span><span class="err">\</span><span class="nt">&gt;</span>\<span class="nt">&lt;/div</span><span class="err">\</span><span class="nt">&gt;</span>
</code></pre></div></div>

<p>Здесь кроется еще одна важная особенность обработки атрибутов библиотекой: они рассматриваются как строки. И если в атрибуте текст, что его надо представить в виде текста (то же характерно для любого юиндига bo-*). Мы привыкли чаще всего работать с числами, но не стоит забывать, что есть еще буквы.</p>

<p>Поэтому если не уверены в содержимом переменной - пишите строковое предствление: <em>‘’</em>, а не <em>var</em>.</p>

<h3 id="вложенность-элементов">Вложенность элементов</h3>

<p>На картинке профайлера (выше) вы можете увидеть гребенку из кучи вложенных вызовов функций. Если мы посмотрим на эти вывовы под микроскопом отладчиком, то увидим, что это рекурсивный обход дерева dom.</p>

<p>Чем меньше у вас уровней вложенности, тем лучше. Особенно это касается кода, который расположен в циклах.</p>

<p>Так что старайтесь сократить вложенности.</p>

<h3 id="дополнительная-оптимизация-при-обработке-скрытых-элементов">Дополнительная оптимизация при обработке скрытых элементов</h3>

<p>У sly-prevent-evaluation-when-hidden есть одна большая проблема: она опирается только на наличие класса ng-hide, что не совсем уместно если видимость элемента контролируется каким-то другим классом.</p>

<p>В таком случае можно (вообще нужно всегда) использовать следующее расширение директивы (подключаем после подключения scalyr).</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">/</span><span class="err">\</span><span class="o">*</span><span class="err">\</span><span class="o">*</span>  
<span class="err">\</span><span class="o">*</span> <span class="nx">Extended</span> <span class="nx">version</span> <span class="k">of</span> <span class="nx">slyPreventEvaluationWhenHidden</span> <span class="k">from</span> <span class="nx">scalyr</span><span class="p">.</span>  
<span class="err">\</span><span class="o">*</span> <span class="nx">This</span> <span class="nx">version</span> <span class="nx">prevent</span> <span class="nx">evaluation</span> <span class="nx">not</span> <span class="nx">only</span> <span class="nx">when</span> <span class="nx">element</span> <span class="nx">has</span> <span class="kd">class</span> <span class="nx">ng</span><span class="o">-</span><span class="nx">hide</span><span class="p">.</span>  
<span class="err">\</span><span class="o">*</span> <span class="nx">If</span> <span class="nx">element</span> <span class="nx">is</span> <span class="nx">hidden</span> <span class="kd">with</span> <span class="dl">"</span><span class="s2">display: none</span><span class="dl">"</span> <span class="nx">evaluation</span> <span class="nx">is</span> <span class="nx">prevented</span><span class="p">.</span>  
<span class="err">\</span><span class="o">*</span><span class="sr">/ </span><span class="err"> 
</span><span class="nx">angular</span><span class="p">.</span><span class="nx">module</span><span class="p">(</span><span class="dl">'</span><span class="s1">sly</span><span class="dl">'</span><span class="p">)</span>  
 <span class="p">.</span><span class="nx">directive</span><span class="p">(</span><span class="dl">'</span><span class="s1">slyPreventEvaluationWhenHidden</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>  
 <span class="k">return</span> <span class="p">{</span>  
 <span class="na">restrict</span><span class="p">:</span> <span class="dl">'</span><span class="s1">A</span><span class="dl">'</span><span class="p">,</span>  
 <span class="c1">// We create a new scope just because it helps segment the gated watchers  </span>
 <span class="c1">// from the parent scope. Unclear if this is that important for perf.  </span>
 <span class="na">scope</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>  
 <span class="na">compile</span><span class="p">:</span> <span class="kd">function</span> <span class="nx">compile</span><span class="p">(</span><span class="nx">tElement</span><span class="p">,</span> <span class="nx">tAttrs</span><span class="p">)</span> <span class="p">{</span>  
 <span class="k">return</span> <span class="p">{</span>  
 <span class="c1">// We need a separate pre-link function because we want to modify the scope before any of the  </span>
 <span class="c1">// children are passed it.  </span>
 <span class="na">pre</span><span class="p">:</span> <span class="kd">function</span> <span class="nx">preLink</span><span class="p">(</span><span class="nx">scope</span><span class="p">,</span> <span class="nx">element</span><span class="p">,</span> <span class="nx">attrs</span><span class="p">)</span> <span class="p">{</span>  
 <span class="nx">scope</span><span class="p">.</span><span class="nx">$addWatcherGate</span><span class="p">(</span><span class="kd">function</span> <span class="nx">hiddenChecker</span><span class="p">()</span> <span class="p">{</span>  
 <span class="c1">// Should only return true if the element is not hidden.  </span>
 <span class="k">return</span> <span class="o">!</span><span class="nx">element</span><span class="p">.</span><span class="nx">hasClass</span><span class="p">(</span><span class="dl">'</span><span class="s1">ng-hide</span><span class="dl">'</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">element</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="dl">"</span><span class="s2">:visible</span><span class="dl">"</span><span class="p">)</span> <span class="p">;</span>  
 <span class="p">},</span> <span class="kd">function</span> <span class="nx">hiddenDecider</span><span class="p">(</span><span class="nx">watchExpression</span><span class="p">,</span> <span class="nx">listener</span><span class="p">,</span> <span class="nx">equality</span><span class="p">,</span> <span class="nx">directiveName</span><span class="p">)</span> <span class="p">{</span>  
 <span class="c1">// Make an exception for slyShow.. do not gate its watcher.  </span>
 <span class="k">if</span> <span class="p">(</span><span class="nx">isDefined</span><span class="p">(</span><span class="nx">directiveName</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">directiveName</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">slyShow</span><span class="dl">'</span><span class="p">))</span>  
 <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>  
 <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>  
 <span class="p">});</span>  
 <span class="p">},</span>  
 <span class="p">};</span>  
 <span class="p">},</span>  
 <span class="p">};</span>  
 <span class="p">});</span>
</code></pre></div></div>




      <footer class="site-footer">
        
          <span class="site-footer-owner"><a href="https://github.com/RussianPenguin/russianpenguin.github.io">russianpenguin.github.io</a> is maintained by <a href="https://github.com/RussianPenguin">RussianPenguin</a>.</span>
        
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
      </footer>
    </main>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

   ym(69889387, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true
   });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/69889387" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
  </body>
</html>
