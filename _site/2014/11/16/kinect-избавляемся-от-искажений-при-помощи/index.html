<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta name="yandex-verification" content="551ffc5ae1433df6" />
    
    <meta charset="UTF-8">

<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Kinect: избавляемся от искажений при помощи потолка | Чтобы не забыть</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Kinect: избавляемся от искажений при помощи потолка" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Давеча я писал про то, как выглядят данные, которые приходят с сенсора. Такое поведение сенсора просто возмутительно и долго это продолжаться не может. Ок. А что нам потребуется? Нам потребуется потолок. Я внимательно его осмотрел и убедился, что в реальности он плоский. А вот на восстановленом изображении - нифига. Для начала нам нужно сохранить дамп глубин “идеального” потолка. Можно и стену если у вас есть достаточно плоской поверхности. :) В файл будет сохранена двумерная матрица из чисел разделенных пробелами. Строки по строкам и т.д. Позже поймем зачем именно так. Кусочек файла 888 889 890 890 890 890 890 891 890 891 891 892 892 892 892 892 892 892 892 892 891 893 892 892 892 892 892 ... 2047 2047 2047 2047 2047 2047 ... Теперь посмотрим на картинку этой самой плоскости. Для этого запускаем maxima. (%i1) load(numericalio); (%i2) m: read\_matrix(&amp;quot;&amp;lt;путь к файлу с глубинами&amp;gt;&amp;quot;); ($i3) f(x, y) := float(&#39;m [round(x), round(y)]); -- тут мы зададим функцию извлечения нужного значения из матрицы. -- Так как матрица наши данные дискретны -- и существуют только в определенных точках (%i4) plot3d (f(x, y), [x, 1, 640], [y, 1, 480]); О! Круто. Мы что-то видим. Что-то не то :) Стоит заметить, что в режиме сырых данных FREENECT_DEPTH_11BIT самые правые 8 столбцов не используются и всегда возвращают значение FREENECT_DEPTH_RAW_MAX_VALUE. Об этом не стоит забывать при последующих действиях. Поэтому нам нужно посмотреть плоскость без правых столбцов (8 штук). (%i4) plot3d (f(x, y), [x, 1, 632], [y, 1, 480]); И тут уже то, что нам надо. Это плоскость. Но не очень плоская. И таки да. Надо сделать ее обратно плоской. :) Мы знаем, что все точки данной поверхности равноудалены от плоскости, где расположен сенсор. Поэтому можно ввести коэффициент нормировки для каждой из точек (x, y). Который будет равен отношению реального расстояния к полученному. Зная этот коэффициент можно узнать, реальное расстояние до точки. Просто умножив полученное от кинекта значение на коэффициент нормировки в данной точке (x, y). Коэффициенты считаем один раз по калибровочному изображению. А затем загружаем в свое приложение и пользуемся. Минусы решения Я предположил, что коэффициент нормировки зависит только от координат (x, y), но не зависит от глубины. Так это или нет - проверю. (пока датчик говорит, что я прав) Плоскость по которой выполняется калибровка должна находится на расстоянии 2,5-3,5 метров от сенсора. Именно при таком положении коэффициенты нормировки будет точными. Так как сенсор довольно чувствителен, то его положение должно быть параллельно плоскости калибровки (мне помогал обычный строительный уровень) Так же перед калибровкой полученное изображение плоскости нужно сгладить для того, чтобы избавиться от шумов (это умеет делать матлабоский smoothn) UPD Код на гитхабе" />
<meta property="og:description" content="Давеча я писал про то, как выглядят данные, которые приходят с сенсора. Такое поведение сенсора просто возмутительно и долго это продолжаться не может. Ок. А что нам потребуется? Нам потребуется потолок. Я внимательно его осмотрел и убедился, что в реальности он плоский. А вот на восстановленом изображении - нифига. Для начала нам нужно сохранить дамп глубин “идеального” потолка. Можно и стену если у вас есть достаточно плоской поверхности. :) В файл будет сохранена двумерная матрица из чисел разделенных пробелами. Строки по строкам и т.д. Позже поймем зачем именно так. Кусочек файла 888 889 890 890 890 890 890 891 890 891 891 892 892 892 892 892 892 892 892 892 891 893 892 892 892 892 892 ... 2047 2047 2047 2047 2047 2047 ... Теперь посмотрим на картинку этой самой плоскости. Для этого запускаем maxima. (%i1) load(numericalio); (%i2) m: read\_matrix(&amp;quot;&amp;lt;путь к файлу с глубинами&amp;gt;&amp;quot;); ($i3) f(x, y) := float(&#39;m [round(x), round(y)]); -- тут мы зададим функцию извлечения нужного значения из матрицы. -- Так как матрица наши данные дискретны -- и существуют только в определенных точках (%i4) plot3d (f(x, y), [x, 1, 640], [y, 1, 480]); О! Круто. Мы что-то видим. Что-то не то :) Стоит заметить, что в режиме сырых данных FREENECT_DEPTH_11BIT самые правые 8 столбцов не используются и всегда возвращают значение FREENECT_DEPTH_RAW_MAX_VALUE. Об этом не стоит забывать при последующих действиях. Поэтому нам нужно посмотреть плоскость без правых столбцов (8 штук). (%i4) plot3d (f(x, y), [x, 1, 632], [y, 1, 480]); И тут уже то, что нам надо. Это плоскость. Но не очень плоская. И таки да. Надо сделать ее обратно плоской. :) Мы знаем, что все точки данной поверхности равноудалены от плоскости, где расположен сенсор. Поэтому можно ввести коэффициент нормировки для каждой из точек (x, y). Который будет равен отношению реального расстояния к полученному. Зная этот коэффициент можно узнать, реальное расстояние до точки. Просто умножив полученное от кинекта значение на коэффициент нормировки в данной точке (x, y). Коэффициенты считаем один раз по калибровочному изображению. А затем загружаем в свое приложение и пользуемся. Минусы решения Я предположил, что коэффициент нормировки зависит только от координат (x, y), но не зависит от глубины. Так это или нет - проверю. (пока датчик говорит, что я прав) Плоскость по которой выполняется калибровка должна находится на расстоянии 2,5-3,5 метров от сенсора. Именно при таком положении коэффициенты нормировки будет точными. Так как сенсор довольно чувствителен, то его положение должно быть параллельно плоскости калибровки (мне помогал обычный строительный уровень) Так же перед калибровкой полученное изображение плоскости нужно сгладить для того, чтобы избавиться от шумов (это умеет делать матлабоский smoothn) UPD Код на гитхабе" />
<link rel="canonical" href="http://localhost:4000/2014/11/16/kinect-%D0%B8%D0%B7%D0%B1%D0%B0%D0%B2%D0%BB%D1%8F%D0%B5%D0%BC%D1%81%D1%8F-%D0%BE%D1%82-%D0%B8%D1%81%D0%BA%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9-%D0%BF%D1%80%D0%B8-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D0%B8/" />
<meta property="og:url" content="http://localhost:4000/2014/11/16/kinect-%D0%B8%D0%B7%D0%B1%D0%B0%D0%B2%D0%BB%D1%8F%D0%B5%D0%BC%D1%81%D1%8F-%D0%BE%D1%82-%D0%B8%D1%81%D0%BA%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9-%D0%BF%D1%80%D0%B8-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D0%B8/" />
<meta property="og:site_name" content="Чтобы не забыть" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2014-11-16T21:22:20+03:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Kinect: избавляемся от искажений при помощи потолка" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2014/11/16/kinect-%D0%B8%D0%B7%D0%B1%D0%B0%D0%B2%D0%BB%D1%8F%D0%B5%D0%BC%D1%81%D1%8F-%D0%BE%D1%82-%D0%B8%D1%81%D0%BA%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9-%D0%BF%D1%80%D0%B8-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D0%B8/","description":"Давеча я писал про то, как выглядят данные, которые приходят с сенсора. Такое поведение сенсора просто возмутительно и долго это продолжаться не может. Ок. А что нам потребуется? Нам потребуется потолок. Я внимательно его осмотрел и убедился, что в реальности он плоский. А вот на восстановленом изображении - нифига. Для начала нам нужно сохранить дамп глубин “идеального” потолка. Можно и стену если у вас есть достаточно плоской поверхности. :) В файл будет сохранена двумерная матрица из чисел разделенных пробелами. Строки по строкам и т.д. Позже поймем зачем именно так. Кусочек файла 888 889 890 890 890 890 890 891 890 891 891 892 892 892 892 892 892 892 892 892 891 893 892 892 892 892 892 ... 2047 2047 2047 2047 2047 2047 ... Теперь посмотрим на картинку этой самой плоскости. Для этого запускаем maxima. (%i1) load(numericalio); (%i2) m: read\\_matrix(&amp;quot;&amp;lt;путь к файлу с глубинами&amp;gt;&amp;quot;); ($i3) f(x, y) := float(&#39;m [round(x), round(y)]); -- тут мы зададим функцию извлечения нужного значения из матрицы. -- Так как матрица наши данные дискретны -- и существуют только в определенных точках (%i4) plot3d (f(x, y), [x, 1, 640], [y, 1, 480]); О! Круто. Мы что-то видим. Что-то не то :) Стоит заметить, что в режиме сырых данных FREENECT_DEPTH_11BIT самые правые 8 столбцов не используются и всегда возвращают значение FREENECT_DEPTH_RAW_MAX_VALUE. Об этом не стоит забывать при последующих действиях. Поэтому нам нужно посмотреть плоскость без правых столбцов (8 штук). (%i4) plot3d (f(x, y), [x, 1, 632], [y, 1, 480]); И тут уже то, что нам надо. Это плоскость. Но не очень плоская. И таки да. Надо сделать ее обратно плоской. :) Мы знаем, что все точки данной поверхности равноудалены от плоскости, где расположен сенсор. Поэтому можно ввести коэффициент нормировки для каждой из точек (x, y). Который будет равен отношению реального расстояния к полученному. Зная этот коэффициент можно узнать, реальное расстояние до точки. Просто умножив полученное от кинекта значение на коэффициент нормировки в данной точке (x, y). Коэффициенты считаем один раз по калибровочному изображению. А затем загружаем в свое приложение и пользуемся. Минусы решения Я предположил, что коэффициент нормировки зависит только от координат (x, y), но не зависит от глубины. Так это или нет - проверю. (пока датчик говорит, что я прав) Плоскость по которой выполняется калибровка должна находится на расстоянии 2,5-3,5 метров от сенсора. Именно при таком положении коэффициенты нормировки будет точными. Так как сенсор довольно чувствителен, то его положение должно быть параллельно плоскости калибровки (мне помогал обычный строительный уровень) Так же перед калибровкой полученное изображение плоскости нужно сгладить для того, чтобы избавиться от шумов (это умеет делать матлабоский smoothn) UPD Код на гитхабе","headline":"Kinect: избавляемся от искажений при помощи потолка","dateModified":"2014-11-16T21:22:20+03:00","datePublished":"2014-11-16T21:22:20+03:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2014/11/16/kinect-%D0%B8%D0%B7%D0%B1%D0%B0%D0%B2%D0%BB%D1%8F%D0%B5%D0%BC%D1%81%D1%8F-%D0%BE%D1%82-%D0%B8%D1%81%D0%BA%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9-%D0%BF%D1%80%D0%B8-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D0%B8/"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="/assets/css/style.css?v=d85e6f1917405784d52928d499ab3e51b4bffcc9">
  </head>
  <body>
    <header class="page-header" role="banner">
      <h1 class="project-name">Kinect: избавляемся от искажений при помощи потолка</h1>
      <h2 class="project-tagline">Записная книжка рассеянного [в пространстве и времени] программиста</h2>
      
        <a href="https://github.com/RussianPenguin/russianpenguin.github.io" class="btn">View on GitHub</a>
      
      
    </header>

    <main id="content" class="main-content" role="main">
      <h1>Kinect: избавляемся от искажений при помощи потолка</h1>
<p>16 Nov 2014</p>

<p><a href="https://russianpenguin.files.wordpress.com/2014/11/d180d0b0d0b1d0bed187d0b5d0b5-d0bcd0b5d181d182d0be-2_125.png"><img src="/assets/images/2014/11/d180d0b0d0b1d0bed187d0b5d0b5-d0bcd0b5d181d182d0be-2_125.png?w=150" alt="Идеально плоский потолок" /></a>Давеча я <a href="http://russianpenguin.ru/2014/11/16/kinect-%D0%BE-%D0%B2%D0%BE%D1%81%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B8-%D0%BA%D0%BE%D0%BE%D1%80%D0%B4%D0%B8%D0%BD%D0%B0%D1%82-%D0%B8-%D0%B0%D0%B1%D0%B1%D0%B5%D1%80%D0%B0/" title="Kinect: о восстановлении координат и абберациях разного рода">писал</a> про то, как выглядят данные, которые приходят с сенсора. Такое поведение сенсора просто возмутительно и долго это продолжаться не может.</p>

<p>Ок. А что нам потребуется? Нам потребуется потолок. Я внимательно его осмотрел и убедился, что в реальности он плоский. А вот на восстановленом изображении - нифига.</p>

<p>Для начала нам нужно сохранить дамп глубин “идеального” потолка. Можно и стену если у вас есть достаточно плоской поверхности. :)</p>

<p>В файл будет сохранена двумерная матрица из чисел разделенных пробелами. Строки по строкам и т.д. Позже поймем зачем именно так.</p>

<p>Кусочек файла</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>888 889 890 890 890 890 890 891 890 891 891 892 892 892 892 892 892 892 892 892 891 893 892 892 892 892 892 ... 2047 2047 2047 2047 2047 2047 ...
</code></pre></div></div>

<p>Теперь посмотрим на картинку этой самой плоскости. Для этого запускаем <a href="http://maxima.sourceforge.net/" title="Maxima, a Computer Algebra System">maxima.</a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(%i1) load(numericalio);  
(%i2) m: read\_matrix(&amp;quot;&amp;lt;путь к файлу с глубинами&amp;gt;&amp;quot;);  
($i3) f(x, y) := float('m [round(x), round(y)]);  
-- тут мы зададим функцию извлечения нужного значения из матрицы.  
-- Так как матрица наши данные дискретны  
-- и существуют только в определенных точках  
(%i4) plot3d (f(x, y), [x, 1, 640], [y, 1, 480]);
</code></pre></div></div>

<p>О! Круто. Мы что-то видим.</p>

<p><a href="https://russianpenguin.files.wordpress.com/2014/11/d0b2d18bd0b4d0b5d0bbd0b5d0bdd0b8d0b5_124.png"><img src="/assets/images/2014/11/d0b2d18bd0b4d0b5d0bbd0b5d0bdd0b8d0b5_124.png?w=300" alt="Потолок. Необработанная карта глубин" /></a></p>

<p>Что-то не то :)</p>

<p>Стоит заметить, что в режиме сырых данных FREENECT_DEPTH_11BIT самые правые 8 столбцов не используются и всегда возвращают значение FREENECT_DEPTH_RAW_MAX_VALUE. Об этом не стоит забывать при последующих действиях.</p>

<p>Поэтому нам нужно посмотреть плоскость без правых столбцов (8 штук).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(%i4) plot3d (f(x, y), [x, 1, 632], [y, 1, 480]);
</code></pre></div></div>

<p>И тут уже то, что нам надо.</p>

<p><a href="https://russianpenguin.files.wordpress.com/2014/11/d0b2d18bd0b4d0b5d0bbd0b5d0bdd0b8d0b5_123.png"><img src="/assets/images/2014/11/d0b2d18bd0b4d0b5d0bbd0b5d0bdd0b8d0b5_123.png?w=300" alt="Потолок: карта глубин после доработки" /></a>Это плоскость. Но не очень плоская. И таки да. Надо сделать ее обратно плоской. :)</p>

<p>Мы знаем, что все точки данной поверхности равноудалены от плоскости, где расположен сенсор.</p>

<p>Поэтому можно ввести коэффициент нормировки для каждой из точек (x, y). Который будет равен отношению реального расстояния к полученному.</p>

<p>Зная этот коэффициент можно узнать, реальное расстояние до точки. Просто умножив полученное от кинекта значение на коэффициент нормировки в данной точке (x, y).</p>

<p>Коэффициенты считаем один раз по калибровочному изображению. А затем загружаем в свое приложение и пользуемся.</p>

<p>Минусы решения</p>

<ul>
  <li>Я предположил, что коэффициент нормировки зависит только от координат (x, y), но не зависит от глубины. Так это или нет - проверю. (пока датчик говорит, что я прав)</li>
  <li>Плоскость по которой выполняется калибровка должна находится на расстоянии 2,5-3,5 метров от сенсора. Именно при таком положении коэффициенты нормировки будет точными.</li>
  <li>Так как сенсор довольно чувствителен, то его положение должно быть параллельно плоскости калибровки (мне помогал обычный строительный уровень)</li>
  <li>Так же перед калибровкой полученное изображение плоскости нужно сгладить для того, чтобы избавиться от шумов (это умеет делать матлабоский <a href="http://www.biomecardio.com/matlab/smoothn.html#11" title="Matlab: smoothn">smoothn</a>)</li>
</ul>

<p><strong>UPD</strong></p>

<p><a href="https://github.com/RussianPenguin/kinectDepthView" title="Kinect depth view with Ogre3d">Код на гитхабе</a></p>




      <footer class="site-footer">
        
          <span class="site-footer-owner"><a href="https://github.com/RussianPenguin/russianpenguin.github.io">russianpenguin.github.io</a> is maintained by <a href="https://github.com/RussianPenguin">RussianPenguin</a>.</span>
        
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
      </footer>
    </main>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

   ym(69889387, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true
   });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/69889387" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
  </body>
</html>
