<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta name="yandex-verification" content="551ffc5ae1433df6" />
    
    <meta charset="UTF-8">

<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Python 3+ и окончания строк в файлах | Чтобы не забыть</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Python 3+ и окончания строк в файлах" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Столкнулся одного теста, который был перенесен с python 2+ на python 3+. Тест делал следующее: скачивал файл через python.requests и сравнивал его с эталонным содержимым на диске (посимвольно). Выглядело приблизительно так import requests import sys response = requests.get(sys.argv[1]) if response.code == 200: with open(sys.argv[2]) as f: from\_storage = f.read() from\_web = response.text assert from\_web == from\_storage Да. Все верно. Этот тест не проходил. И тут была замечена одна странность: файл на диске содержал последовательность crlf, а в coдержимом from_storage этой последовательности не оказало. А дело все в том, что в python 3+ было введено соглашение на обработку символов перевода строки. И управление работой осуществляется манипулированием параметром newline. On input, if newline is None, universal newlines mode is enabled. Lines in the input can end in ‘\n’, ‘\r’, or ‘\r\n’, and these are translated into ‘\n’ before being returned to the caller. If it is ‘’, universal newline mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated. On output, if newline is None, any ‘\n’ characters written are translated to the system default line separator, os.linesep. If newline is ‘’, no translation takes place. If newline is any of the other legal values, any ‘\n’ characters written are translated to the given string. В итоге достаточно было указать newline=’’ как CRLF появились." />
<meta property="og:description" content="Столкнулся одного теста, который был перенесен с python 2+ на python 3+. Тест делал следующее: скачивал файл через python.requests и сравнивал его с эталонным содержимым на диске (посимвольно). Выглядело приблизительно так import requests import sys response = requests.get(sys.argv[1]) if response.code == 200: with open(sys.argv[2]) as f: from\_storage = f.read() from\_web = response.text assert from\_web == from\_storage Да. Все верно. Этот тест не проходил. И тут была замечена одна странность: файл на диске содержал последовательность crlf, а в coдержимом from_storage этой последовательности не оказало. А дело все в том, что в python 3+ было введено соглашение на обработку символов перевода строки. И управление работой осуществляется манипулированием параметром newline. On input, if newline is None, universal newlines mode is enabled. Lines in the input can end in ‘\n’, ‘\r’, or ‘\r\n’, and these are translated into ‘\n’ before being returned to the caller. If it is ‘’, universal newline mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated. On output, if newline is None, any ‘\n’ characters written are translated to the system default line separator, os.linesep. If newline is ‘’, no translation takes place. If newline is any of the other legal values, any ‘\n’ characters written are translated to the given string. В итоге достаточно было указать newline=’’ как CRLF появились." />
<link rel="canonical" href="http://localhost:4000/2015/02/17/python-3-%D0%B8-%D0%BE%D0%BA%D0%BE%D0%BD%D1%87%D0%B0%D0%BD%D0%B8%D1%8F-%D1%81%D1%82%D1%80%D0%BE%D0%BA-%D0%B2-%D1%84%D0%B0%D0%B9%D0%BB%D0%B0%D1%85/" />
<meta property="og:url" content="http://localhost:4000/2015/02/17/python-3-%D0%B8-%D0%BE%D0%BA%D0%BE%D0%BD%D1%87%D0%B0%D0%BD%D0%B8%D1%8F-%D1%81%D1%82%D1%80%D0%BE%D0%BA-%D0%B2-%D1%84%D0%B0%D0%B9%D0%BB%D0%B0%D1%85/" />
<meta property="og:site_name" content="Чтобы не забыть" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-02-17T23:53:18+03:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Python 3+ и окончания строк в файлах" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2015/02/17/python-3-%D0%B8-%D0%BE%D0%BA%D0%BE%D0%BD%D1%87%D0%B0%D0%BD%D0%B8%D1%8F-%D1%81%D1%82%D1%80%D0%BE%D0%BA-%D0%B2-%D1%84%D0%B0%D0%B9%D0%BB%D0%B0%D1%85/","description":"Столкнулся одного теста, который был перенесен с python 2+ на python 3+. Тест делал следующее: скачивал файл через python.requests и сравнивал его с эталонным содержимым на диске (посимвольно). Выглядело приблизительно так import requests import sys response = requests.get(sys.argv[1]) if response.code == 200: with open(sys.argv[2]) as f: from\\_storage = f.read() from\\_web = response.text assert from\\_web == from\\_storage Да. Все верно. Этот тест не проходил. И тут была замечена одна странность: файл на диске содержал последовательность crlf, а в coдержимом from_storage этой последовательности не оказало. А дело все в том, что в python 3+ было введено соглашение на обработку символов перевода строки. И управление работой осуществляется манипулированием параметром newline. On input, if newline is None, universal newlines mode is enabled. Lines in the input can end in ‘\\n’, ‘\\r’, or ‘\\r\\n’, and these are translated into ‘\\n’ before being returned to the caller. If it is ‘’, universal newline mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated. On output, if newline is None, any ‘\\n’ characters written are translated to the system default line separator, os.linesep. If newline is ‘’, no translation takes place. If newline is any of the other legal values, any ‘\\n’ characters written are translated to the given string. В итоге достаточно было указать newline=’’ как CRLF появились.","headline":"Python 3+ и окончания строк в файлах","dateModified":"2015-02-17T23:53:18+03:00","datePublished":"2015-02-17T23:53:18+03:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2015/02/17/python-3-%D0%B8-%D0%BE%D0%BA%D0%BE%D0%BD%D1%87%D0%B0%D0%BD%D0%B8%D1%8F-%D1%81%D1%82%D1%80%D0%BE%D0%BA-%D0%B2-%D1%84%D0%B0%D0%B9%D0%BB%D0%B0%D1%85/"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="/assets/css/style.css?v=d85e6f1917405784d52928d499ab3e51b4bffcc9">
  </head>
  <body>
    <header class="page-header" role="banner">
      <h1 class="project-name">Python 3+ и окончания строк в файлах</h1>
      <h2 class="project-tagline">Записная книжка рассеянного [в пространстве и времени] программиста</h2>
      
        <a href="https://github.com/RussianPenguin/russianpenguin.github.io" class="btn">View on GitHub</a>
      
      
    </header>

    <main id="content" class="main-content" role="main">
      <h1>Python 3+ и окончания строк в файлах</h1>
<p>17 Feb 2015</p>

<p>Столкнулся одного теста, который был перенесен с python 2+ на python 3+.</p>

<p>Тест делал следующее:</p>

<p>скачивал файл через python.requests и сравнивал его с эталонным содержимым на диске (посимвольно).</p>

<p>Выглядело приблизительно так</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">requests</span>  
<span class="kn">import</span> <span class="nn">sys</span>  
<span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  
<span class="k">if</span> <span class="n">response</span><span class="p">.</span><span class="n">code</span> <span class="o">==</span> <span class="mi">200</span><span class="p">:</span>  
 <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>  
 <span class="k">from</span>\<span class="n">_storage</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>  
 <span class="k">from</span>\<span class="n">_web</span> <span class="o">=</span> <span class="n">response</span><span class="p">.</span><span class="n">text</span>  
 <span class="k">assert</span> <span class="k">from</span>\<span class="n">_web</span> <span class="o">==</span> <span class="k">from</span>\<span class="n">_storage</span>
</code></pre></div></div>

<p>Да. Все верно. Этот тест не проходил.</p>

<p>И тут была замечена одна странность: файл на диске содержал последовательность crlf, а в coдержимом from_storage этой последовательности не оказало.</p>

<p>А дело все в том, что в python 3+ было введено <a href="https://docs.python.org/release/3.2/library/functions.html#open" title="Python 3+ - open function">соглашение</a> на обработку символов перевода строки. И управление работой осуществляется манипулированием параметром newline.</p>

<ul>
  <li>On input, if newline is None, universal newlines mode is enabled. Lines in the input can end in ‘\n’, ‘\r’, or ‘\r\n’, and these are translated into ‘\n’ before being returned to the caller. If it is ‘’, universal newline mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.</li>
  <li>On output, if newline is None, any ‘\n’ characters written are translated to the system default line separator, os.linesep. If newline is ‘’, no translation takes place. If newline is any of the other legal values, any ‘\n’ characters written are translated to the given string.</li>
</ul>

<p>В итоге достаточно было указать newline=’’ как CRLF появились.</p>




      <footer class="site-footer">
        
          <span class="site-footer-owner"><a href="https://github.com/RussianPenguin/russianpenguin.github.io">russianpenguin.github.io</a> is maintained by <a href="https://github.com/RussianPenguin">RussianPenguin</a>.</span>
        
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
      </footer>
    </main>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

   ym(69889387, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true
   });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/69889387" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
  </body>
</html>
