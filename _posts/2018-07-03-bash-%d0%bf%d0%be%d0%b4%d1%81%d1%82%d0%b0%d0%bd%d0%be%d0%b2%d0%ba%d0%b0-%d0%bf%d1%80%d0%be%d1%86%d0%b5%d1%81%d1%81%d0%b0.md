---
layout: post
title: 'Bash: подстановка процесса'
date: 2018-07-03 23:20:52.000000000 +03:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- HowTo
tags:
- bash
- linux
meta:
  _wpcom_is_markdown: '1'
  timeline_notification: '1530649257'
  _rest_api_published: '1'
  _rest_api_client_id: "-1"
  _publicize_job_id: '19632746832'
author:
  login: russianpenguin
  email: maksim.v.zubkov@gmail.com
  display_name: russianpenguin
  first_name: Maksim
  last_name: Zubkov
permalink: "/2018/07/03/bash-%d0%bf%d0%be%d0%b4%d1%81%d1%82%d0%b0%d0%bd%d0%be%d0%b2%d0%ba%d0%b0-%d0%bf%d1%80%d0%be%d1%86%d0%b5%d1%81%d1%81%d0%b0/"
excerpt: |-
  В статье рассматривается механизм командной оболочки linux "подстановка процессов".
  Этот функционал позволяет минимизировать использование именованных каналов для связи между командами или процессами.
---
![2018-07-03-22:14:15_267x133]({{ site.baseurl }}/assets/images/2018/07/2018-07-03-221415_267x133.png)Рассмотрим достаточно полезную штуку в консоли линукса (bash) как подстановка процесса.

Вообще подстановок в баше достаточно [много](http://rus-linux.net/nlib.php?name=/MyLDP/BOOKS/Bash-Guide-1.12-ru/bash-guide-03-4.html) всяких подстановок: результата выполнения команды&nbsp; арифметических операций, имен файлов, значений переменных и, конечно же, процессов.

Применима подстановка в первую очередь для того, чтобы избавиться от создания [пайпов](http://russianpenguin.ru/2014/05/10/linux-%d0%b8%d0%bc%d0%b5%d0%bd%d0%be%d0%b2%d0%b0%d0%bd%d0%bd%d1%8b%d0%b5-%d0%ba%d0%b0%d0%bd%d0%b0%d0%bb%d1%8b/).А во вторую - для сохранения внешнего контекста при работе подпроцесса.

## Избавляемся от пайпов

Имеем две команды, которые формируют некоторый список значений и мы хотим сделать diff или любую другую операцию, которая принимает на вход в качестве аргументов имена файлов.

<!--more-->

Начнем с простого примера: хотим сравнить выводы двух команд.

```shell
$ sleep $((RANDOM%2)) && curl -v --silent https://google.com | grep date
```

На месте этой абсурдной команды может быть что угодно: обработка логов, данные телеметрии с сервера и т.п.

Как сделать diff? Два варианта: перенаправить выводы обеих команд в пайпы и использовать подстановку процессов в форме чтения вывода команды.

```
\<(command)
```

```shell
% mkfifo f1  
$ mkfifo f2  
$ sleep $((RANDOM%2)) && curl -v --silent https://google.com | grep date \> f1 &  
$ sleep $((RANDOM%2)) && curl -v --silent https://google.com | grep date \> f2 &  
$ diff f1 f2  
$ rm f1 f2
```

Либо более лаконично.

```shell
$ diff \<(sleep $((RANDOM%2)) && curl -v --silent https://google.com | grep date) \<(sleep $((RANDOM%2)) && curl -v --silent https://google.com | grep date)
```

Согласитесь, что второй вариант проще в создании. так как оболочка сама позаботилась о создании и удалении каналов. Другая форма использования перенаправить некоторый stdin на вход другой команды или цепочки команд.

```
\>(command)
```

Допустим мы хотим записывать логи подключения разных групп устройств из udevadm в разные файлы. Можно запустить два процесса, но зачем?

```shell
$ udevadm monitor | tee \>(grep card \> card.log) \>(grep usb \> usb.log)
```

Тут не стоит забывать, что множественное перенаправление данных позволительно сделать при помощи tee, который берез stdin и пишет его во все указанные в качестве аргументов файлы.

## Сохранение контекста

Подпроцесс - это одно из ключевых понятий bash и других оболочек.

```shell
 $ export foo=baz  
$ perl -e 'system "echo foo is \$foo"; $ENV{"foo"}="bar"; system "echo foo is \$foo"'  
$ echo "$foo"
```

Perl запускается как дочерний процесс, родителем которого выступает bash (в нашем случае). Для данного процесса создается новый контекст, в который копируются переменные окружения и модификация контекста процесса не приводит к изменению контекста родителя.

Это приводит к тому, что модификация контекста внутри цепочки команд не отражается на глобальных переменных.

```shell
#!/usr/bin/env bash  
i=0  
sort test | while read line; do  
 i=$(($i+1))  
 echo $i  
done  
echo $i
```

В данном скрипте цикл while запускается как дочерний процесс, а следовательно у нас всегда будет выводиться 0. Хотя внутри самого цикла мы видим инкремент переменной.

Исправить ситуацию можно при помощи подстановки команд.

```shell
#!/usr/bin/env bash  
i=0  
while read line; do  
 i=$(($i+1))  
 echo $i  
done \< \<(sort test)  
echo $i
```

## Литература

- [Подстановки, выполняемые командной оболочкой](http://rus-linux.net/nlib.php?name=/MyLDP/BOOKS/Bash-Guide-1.12-ru/bash-guide-03-4.html)
- [Process Substitution](http://mywiki.wooledge.org/ProcessSubstitution)
- [SubShell](http://mywiki.wooledge.org/SubShell)

&nbsp;

