---
layout: post
title: 'Часть 3: Разработка через тестирование, TDD (Тестирование ПО)'
date: 2017-04-12 16:09:35.000000000 +03:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Разработка
tags:
- composer
- php
- phpunit
- tdd
meta:
  _wpcom_is_markdown: '1'
  _rest_api_published: '1'
  _rest_api_client_id: "-1"
  _publicize_job_id: '3913783236'
author:
  login: russianpenguin
  email: maksim.v.zubkov@gmail.com
  display_name: russianpenguin
  first_name: Maksim
  last_name: Zubkov
permalink: "/2017/04/12/%d1%82%d0%b5%d1%81%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d0%bf%d0%be-%d1%87%d0%b0%d1%81%d1%82%d1%8c-3/"
excerpt: В этой части чикла статей "Тестирование ПО" рассматривается как разрабатывать
  системы с применением методологии TDD.
---
<h2><a href="http://russianpenguin.ru/%d1%82%d0%b5%d1%81%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d0%bf%d0%be/">Оглавление</a></h2>
<p><img class=" alignright" title="" src="{{ site.baseurl }}/assets/images/2017/04/image2.png" alt="" width="288" height="206" /><br />
Блочное тестирование уже укоренилось в качестве полезной практики работы с кодом. Протестированный код дает разработчикам уверенность в том, что результат отвечает намерению. Методика разработки, управляемой тестами - это следующий шаг, заключающийся в том, что тесты пишутся раньше, чем код.</p>
<p>Мизерные затраты на написание программ, тестирующих другие программы позволяют нам применять этот способ верификации на всех этапах тестирования: блочное, функциональное, комплексное и приемочное.</p>
<p><!--more--></p>
<p>У строгого применения TDD есть и другие достоинства - их так много, что обычно всех они расшифровывают акроним TDD как test-driven design (проектирование, управляемое тестами). TDD заставляет по-другому подходить к кодированию. Вместо того, чтобы писать массивный кусок кода, а потом тесты для него, TDD заставляет продумать весь процесс тестирования еще до написания первой строчки.</p>
<h2>TDD и блочные тесты</h2>
<p>Рассмотрим на примере те преимущества, которые приносит TDD. Для этого нам понадобится не тривиальная задача, чтобы не работать на корзину, но и не слишком сложная, чтобы не погрязнуть в деталях. Прекрасный вариант - поиск <i>совершенных чисел</i>. Совершенным называется натуральное число, равное сумме собственных делителей (то есть всех делителей, отличных от самого числа). Например 6 - совершенное число, так как сумма его собственных делителей (1, 2, 3) равна 6. Напишем на php небольшую программу, которая будет отыскивать совершенные числа.</p>
<p>Следующий код был написан без применения TDD - полагаясь на простую логику и мелкие математические оптимизации.</p>
<p>[code lang="php"]function isPerfect($number)<br />
{<br />
   // Получить делители<br />
   $factors = [];<br />
   $factors[] = 1;<br />
   $factors[] = $number;</p>
<p>   for ($i = 2; $i &lt; sqrt($number) + 1; $i++) // примечание [1]<br />
   {<br />
       if ($number % $i == 0)<br />
       {<br />
           $factors[] = $i;<br />
           if (intdiv($number, $i) != $i) // примечание [2}<br />
           {<br />
               $factors[] = $number / $i;<br />
           }<br />
       }<br />
   }</p>
<p>   // Вычислить сумму делителей<br />
   $sum = 0;</p>
<p>   foreach ($factors as $i)<br />
   {<br />
       $sum += $i;<br />
   }</p>
<p>   // Проверить, является ли число совершенным<br />
   return $sum - $number == $number;<br />
}</p>
<p>$number = 0;<br />
fscanf(STDIN, &quot;%d\n&quot;, $number);</p>
<p>if (isPerfect($number))<br />
{<br />
   echo &quot;{$number} is perfect number\n&quot;;<br />
}<br />
[/code]<br />
<strong>Примечания:</strong></p>
<ul>
<li>Поскольку получать делители можно парами, нужно перебирать только числа, не превышающие квадратный корень из исходного числа.
<p>Например если для числа 28 найден делитель 2, то сразу можно получить и симметричный делитель 14.</li>
<li>Проверка <i>intdiv($number, $i) != $i</i> включена для того, чтобы не учитывать одно и то же число дважды.
<p>Мы получаем делители парами, но что случится, если число - полный квадрат? Например для числа 16 делитель 4 следует включить в список только один раз.</li>
</ul>
<p>Весь код - это один единственный метод, который возвращает <i>true</i> или <i>false</i> в зависимости от того, является ли переданное число совершенным. На первом шаге мы находим все делители. Поскольку 1 и само число являются делителями всегда, то добавляем их в список. Затем в цикле мы доходим до квадратного корня из числа. Эта мелкая оптимизация сделана потому что мы получаем делители парами, поэтому достаточно проверить числа не превышающие квадратный корень.</p>
<p>Возможно ли протестировать этот код? В данной реализации его можно протестировать лишь на каком-то заведомо известном наборе чисел. Сказать, что конкретно этот алгоритм выполняется корректно мы можем лишь благодаря возможности доказать его правильность математически, но не практически.</p>
<p>Так как же может (но не обязательно должен!) выглядеть код, который можно протестировать?</p>
<p>Чтобы ответить на этот вопрос мы применим методологию TDD и будем создавать дизайн проекта основываясь на тестах. В данном примере будет использоваться инструментарий PHPUnit, который создан для того, чтобы брать на себя все необходимые манипуляции по управлению и запуску тестовых сценариев, оставляя на совести разработчика лишь создание самих кейсов. Чуть позже мы подробно с ним познакомимся, а сейчас же нам потребуется от него лишь базовый функционал.</p>
<h3><b>Создаем инфраструктуру</b></h3>
<p>Перед тем, как приступить к написанию кода нам потребуется подготовить инфраструктуру для работы. Крайне рекомендуется делать все руками из консоли или файлового менеджера. Так вы сможете лучше понять, как устроена система изнутри.</p>
<ol>
<li>Создаем в папке проекта два каталога: tests и src.</li>
<li>Создаем файл composer.json следующего содержания</li>
</ol>
<p>[code lang="javascript"]{<br />
 &quot;name&quot;: &quot;geekbrains/phptesting&quot;,<br />
 &quot;description&quot;: &quot;PHPUnit, TDD and other&quot;,<br />
 &quot;minimum-stability&quot;: &quot;dev&quot;,<br />
 &quot;license&quot;: &quot;proprietary&quot;,<br />
 &quot;authors&quot;: [<br />
   {<br />
     &quot;name&quot;: &quot;GeekBrains Student&quot;,<br />
     &quot;email&quot;: &quot;email@example.com&quot;<br />
   }<br />
 ],<br />
 &quot;autoload&quot;: {<br />
   &quot;psr-4&quot;: {<br />
     &quot;PerfectNumberTDD\\&quot;: [&quot;src/&quot;]<br />
   }<br />
 },<br />
 &quot;require-dev&quot;: {<br />
   &quot;phpunit/phpunit&quot;: &quot;5.7.4&quot;,<br />
   &quot;squizlabs/php_codesniffer&quot;: &quot;3.0.x-dev&quot;<br />
 }<br />
}[/code]</p>
<ol start="3">
<li>Устанавливаем composer.phar возпользовавший инструкцией по адресу <a href="https://getcomposer.org/download/">https://getcomposer.org/download/</a> (в вашей системе уже должен быть установлен и настроен интерпретатор php). В каталоге проекта должен появиться файл <i>composer.phar</i>.</li>
<li>Запускаем из командного интерпретатора инструкцию <i>php composer.phar install. </i>Установка займет некоторое время. По окончанию в каталоге проекта появится папка vendor c необходимыми для работы компонентами.</li>
<li>Создадим файл phpunit.xml следующего содержания</li>
</ol>
<p>[code lang="xml"]&lt;!-- Обратите внимание, что схема должна соответствовать той версии phpunit, которую вы используете. Схема - это значение атрибута xsi:noNamespaceSchemaLocation --&gt;<br />
&lt;phpunit        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        xsi:noNamespaceSchemaLocation=&quot;http://schema.phpunit.de/5.7/phpunit.xsd&quot;        bootstrap=&quot;vendor/autoload.php&quot;&gt;<br />
   &lt;!--     Указываем где размещаются тесты.     Секций testsuites может быть более одной.     Нужно это для того,     чтобы иметь возможность тестировать различные аспекты системы.    --&gt;<br />
   &lt;testsuites&gt;<br />
       &lt;testsuite name=&quot;Core functionality&quot;&gt;<br />
           &lt;directory&gt;tests&lt;/directory&gt;<br />
       &lt;/testsuite&gt;<br />
   &lt;/testsuites&gt;<br />
   &lt;!--     whitelist для указания того,     какие файлы будут проверяться на покрытие тестами    --&gt;<br />
   &lt;filter&gt;<br />
       &lt;whitelist processUncoveredFilesFromWhitelist=&quot;true&quot;&gt;<br />
           &lt;directory suffix=&quot;.php&quot;&gt;src&lt;/directory&gt;<br />
       &lt;/whitelist&gt;<br />
   &lt;/filter&gt;<br />
&lt;/phpunit&gt;[/code]</p>
<ol start="6">
<li>В каталоге tests создадим файл <i>PerfectNumberTest.php</i> и напишем в нем несколько строк кода</li>
</ol>
<p>[code lang="php"]namespace PerfectNumberTDD;</p>
<p>use PHPUnit_Framework_TestCase;</p>
<p>/**<br />
 * Набор тестовых случаев для проверки класса PerfectNumber<br />
 */<br />
class PerfectNumberTest extends PHPUnit_Framework_TestCase<br />
{<br />
   /*<br />
    * В этом классе мы будем писать тесты.<br />
    */<br />
}[/code]</p>
<ol start="7">
<li>Для проверки того, что все правильно сделано следует выполнить в консоли (находясь в каталоге проекта команду <i>php vendor/bin/phpunit -c phpunit.xml</i>.
<p>Мы увидим сообщение о том, что тесты не найдены. Все верно. Ведь мы не написали еще ни одного теста.</li>
</ol>
<p>[code lang="shell"]PHPUnit 5.7.4 by Sebastian Bergmann and contributors.</p>
<p>W                                                                   1 / 1 (100%)</p>
<p>Time: 23 ms, Memory: 4.00MB</p>
<p>There was 1 warning:</p>
<p>1) Warning<br />
No tests found in class &quot;PerfectNumberTDD\PerfectNumberTest&quot;.</p>
<p>WARNINGS!<br />
Tests: 1, Assertions: 0, Warnings: 1.[/code]</p>
<ol start="8">
<li>Теперь вся инфраструктура для создания проекта готова и можно приступать.</li>
</ol>
<h3>Разработка посредством TDD</h3>
<p>Вначале нам стоит задуматься о том, какими свойствами должен обладать еще не написанный код. Во-первых это должен быть объект. Этот факт исходит из того, что наш код должен обладать некоторым набором методов. Такими как проверка является ли число делителем, добавления новых делителей в список. Во-вторых этот тип данных должен быть иммутабельным (immutable) или другими словами неизменяемым. Этот факт следует из того, что нельзя изменить список делителей числа - он всегда один и то же, а так же нельзя изменить для числа свойство, которое указывает совершенное оно или нет. Так же, как мы увидим дальше, свойство неизменяемости делает код более лаконичным.</p>
<p>Напишем первый тест, который покажет, что создался нужный экземпляр объекта (все тесты следует размещать в классе <i>PerfectNumberTest</i>).</p>
<p>[code lang="php"]/**<br />
 * Проверим, что создался нужный экземпляр<br />
 */<br />
public function testPerfectNumberCreation()<br />
{<br />
   $p = new PerfectNumber(1);<br />
   $this-&gt;assertInstanceOf('\PerfectNumberTDD\PerfectNumber', $p);<br />
}[/code]<br />
Этот тест не делает ничего, кроме проверки на корректность создания объекта. И такие тесты на самом деле пишутся крайне редко.</p>
<p>Методы, которые начинаются со слова assert обозначают какую-либо проверку. В данном случае мы проверяем, что экземпляр класса $p действительно имеет тип базовый тип <i>\PerfectNumberTDD\PerfectNumber </i>(класс с именем <i>PerfectNumber</i>, который расположен в пространстве имен <i>PerfectNumberTDD).</i></p>
<p>Попытаемся запустить данный тест. В консоли перейдем в папку с проектом и запустим команду</p>
<p>[code]php vendor/bin/phpunit -c phpunit.xml[/code]<br />
Мы увидим ошибку о том, что класс не найден (и это вполне ожидаемо, так как мы написали тест, но не класс).</p>
<p>[code]PHPUnit 5.7.4 by Sebastian Bergmann and contributors.</p>
<p>E                                                                   1 / 1 (100%)</p>
<p>Time: 20 ms, Memory: 4.00MB</p>
<p>There was 1 error:</p>
<p>1) PerfectNumberTDD\PerfectNumberTest::testPerfectNumberCreation<br />
Error: Class 'PerfectNumberTDD\PerfectNumber' not found</p>
<p>/tmp/prj/tests/PerfectNumberTest.php:17</p>
<p>ERRORS!<br />
Tests: 1, Assertions: 0, Errors: 1.[/code]<br />
И это одна из особенностей разработки с применением методологии TDD - разработчик сначала создает тесты (которые конечно же не проходят) и лишь затем создает код, который реализует проверяемую функциональность, а тесты начинают выполняться корректно.</p>
<p>Далее мы не будем подробно останавливаться на запуске тестов, а будем лишь обсуждать результат и писать код.</p>
<p>Очевидно, что нам требуется написать какой-то код, который реализует проверяемый кейс. Создадим в каталоге src файл PerfectNumber.php со следующим содержимым.</p>
<p>[code lang="php"]namespace PerfectNumberTDD;</p>
<p>class PerfectNumber<br />
{<br />
    public function __construct($number)<br />
    {<br />
    }<br />
}[/code]<br />
И далее запустите тесты на исполнение. Как вы можете видеть, все тесты прошли успешно. А это значит, что первый из проверяемых аспектов успешно реализован.</p>
<p>Следующим тестом станет проверка, что единица всегда является делителем числа.</p>
<p>[code lang="php"]/**<br />
 * Проверяем, что делителями числа 1 является только единица.<br />
 */<br />
public function testFactorsFor1()<br />
{<br />
   $expected = [1];<br />
   $p = new PerfectNumber(1);<br />
   $this-&gt;assertEquals($expected, $p-&gt;getFactors(), &quot;&quot;, 0.0, 10, true);<br />
}[/code]<br />
Здесь появляются новые методы и функциональность - это метод, который вернет список делителей числа. Не стоит пока заострять внимание на огромном количестве аргументов у assertEquals - он лишь позволяет сравнивать массивы <i>$expected</i> и тот, что вернул <i>getFactors()</i> без учета порядка аргументов.</p>
<p>Иными словами, два массива [1, 2] и [2, 1] будут считаться одинаковыми, так как содержат одинаковый набор элементов.</p>
<p>Почему этот и предыдущий тест считаются полезными, ведь он совсем простой? Чаще всего эти тесты пишутся не для тестирования программы, а для тестирования инфраструктуры. Они позволяют выявить что-то пошло не так еще до начала тестирования сложных элементов кода.</p>
<p>Ведь нам требуется правильно настроить переменные окружения, поставить дополнительное по, настроить composer.</p>
<p>Некоторые разработчики называют подобные тесты <i>тестами канарейки</i>. Как и канарейка, которую берут в шахты, эти тесты погибают при первых признаках некорректного окружения.</p>
<p>Напишем код, который реализует проверяемый аспект.</p>
<p>[code lang="php"]namespace PerfectNumberTDD;</p>
<p>class PerfectNumber<br />
{<br />
   private $number;<br />
   private $factors;</p>
<p>   public function __construct($number)<br />
   {<br />
       $this-&gt;number = $number;<br />
       $this-&gt;factors = [];</p>
<p>       $this-&gt;factors[] = 1;<br />
   }</p>
<p>   public function getFactors()<br />
   {<br />
       return $this-&gt;factors;<br />
   }<br />
}[/code]<br />
Вспомним наш предыдущий вариант: делителем числа кроме единицы так же является и само число. Напишем тест, который заведомо не пройдет.</p>
<p>[code lang="php"]public function testFactorsContainNumber()<br />
{<br />
   $p = new PerfectNumber(100);<br />
   $this-&gt;assertContains(100, $p-&gt;getFactors());<br />
   $this-&gt;assertContains(1, $p-&gt;getFactors());<br />
}[/code]<br />
Убедившись, что тест все же не прошел, расширим функционал класса, изменив конструктор.</p>
<p>[code lang="php"]public function __construct($number)<br />
{<br />
   $this-&gt;number = $number;<br />
   $this-&gt;factors = [];</p>
<p>   $this-&gt;factors[] = 1;<br />
   $this-&gt;factors[] = $number;<br />
}[/code]<br />
И как мы видим, тест <i>testFactorsFor1</i> сломался. И немудрено: ведь массив factors не должен содержать дубликатов числа. Поправим это недоразумение.</p>
<p>[code lang="php"]public function __construct($number)<br />
{<br />
   $this-&gt;number = $number;<br />
   $this-&gt;factors = [];</p>
<p>   $this-&gt;factors[] = 1;<br />
   if (!in_array($number, $this-&gt;factors) &amp;&amp; $number &gt; 0) {<br />
       $this-&gt;factors[] = $number;<br />
   }<br />
}[/code]<br />
А теперь подумаем: при проверке всех делителей числа нам потребуется их добавлять в список делителей. Делать это постоянно обращаясь к массиву <i>$this-&gt;factor</i> неправильно. И нам потребуется метод добавления в список. Почему метод? Вспомним, что в php нет множеств, а список делителей числа должен быть множеством потому что каждое значение в нем должно повторяться ровно один раз. Также нам нельзя добавлять в список делителей ноль и отрицательные числа. А для этого нам потребуется придумать некоторый способ проверять на делимость. Напишем несколько тестов.</p>
<p>[code lang="php"]public function testZeroIsNotFactor()<br />
{<br />
   // Не имеет значения, какое число мы будем использовать<br />
   $p = new PerfectNumber(42);<br />
   $this-&gt;assertFalse($p-&gt;isFactor(0));<br />
}</p>
<p>public function testIsFactor()<br />
{<br />
   $p1 = new PerfectNumber(10);<br />
   $this-&gt;assertTrue($p1-&gt;isFactor(1));</p>
<p>   $p2 = new PerfectNumber(25);<br />
   $this-&gt;assertTrue($p2-&gt;isFactor(5));</p>
<p>   $p3 = new PerfectNumber(25);<br />
   $this-&gt;assertFalse($p3-&gt;isFactor(6));<br />
}[/code]<br />
И реализуем соответствующий функционал.</p>
<p>[code lang="php"]public function isFactor($factor)<br />
{<br />
   if ($factor &gt; 0) {<br />
       return $this-&gt;number % $factor == 0;<br />
   } else {<br />
       return false;<br />
   }<br />
}[/code]<br />
Видим, что все хорошо. Теперь можно перейти непосредственно к разработке самого метода, который и будет добавлять числа в список делителей. Вспомним, что объект должен быть иммутабельным, а следовательно метод добавления в список должен быть помечен либо как private, либо как protected. Это автоматически накладывает некоторые ограничения на тестирование таких методов. Но благодаря механизму рефлексии в php мы все же сможем их протестировать. Нам для этого потребуется дополнительный код, который мы разместим в классе <i>PerfectNumberTest</i>.</p>
<p>[code lang="php"]public function invokeMethod(&amp;$object, $methodName, array $parameters = array())<br />
{<br />
   $reflection = new \ReflectionClass(get_class($object));<br />
   $method = $reflection-&gt;getMethod($methodName);<br />
   $method-&gt;setAccessible(true);</p>
<p>   return $method-&gt;invokeArgs($object, $parameters);<br />
}[/code]<br />
Теперь мы сможем написать кейс, тестирующий добавление чисел в список делителей.</p>
<p>[code lang="php"]public function testAddFactors()<br />
{<br />
   $p = new PerfectNumber(20);</p>
<p>   $this-&gt;invokeMethod($p, 'addFactor', [2]);<br />
   $this-&gt;invokeMethod($p, 'addFactor', [4]);<br />
   $this-&gt;invokeMethod($p, 'addFactor', [5]);<br />
   $this-&gt;invokeMethod($p, 'addFactor', [10]);</p>
<p>   $expected = [1, 2, 4, 5, 10, 20];<br />
   $this-&gt;assertEquals($expected, $p-&gt;getFactors(), &quot;&quot;, 0.0, 10, true);<br />
}[/code]<br />
Тест провалился, а мы приступаем к написанию кода, который сделает его работающим. Заодно мы исправим конструктор таким образом, чтобы использовался новый метод <i>addFactor()</i>.</p>
<p>[code lang="php"]public function __construct($number)<br />
{<br />
   $this-&gt;number = $number;<br />
   $this-&gt;factors = [];</p>
<p>   $this-&gt;addFactor(1);<br />
   $this-&gt;addFactor($number);<br />
}</p>
<p>protected function addFactor($factor)<br />
{<br />
   if ($this-&gt;isFactor($factor)) {<br />
       // Это не самая удачная строка кода.<br />
       // Она призвана оставить в массиве $this-&gt;factors только уникальные,<br />
       // отличные от нуля значения.<br />
       $this-&gt;factors = array_unique( // оставляем только уникальные значения<br />
           array_merge( // Объединение двух массивов<br />
               // отфильтрованняй массив делителей<br />
               array_filter([$factor, intdiv($this-&gt;number, $factor)]),<br />
               $this-&gt;factors // предыдущее содержимое массива делителей<br />
           )<br />
       );<br />
   }<br />
}[/code]<br />
Мы уже научили код добавлять делители в список делителей. Так почему бы нам не протестировать таким образом метод isPerfect, который скажет о том, является ли число совершенным?</p>
<p>[code lang="php"]public function testIsPerfectCreatedByHands()<br />
{<br />
   $p = new PerfectNumber(6);</p>
<p>   $this-&gt;invokeMethod($p, 'addFactor', [2]);<br />
   $this-&gt;invokeMethod($p, 'addFactor', [3]);<br />
   $this-&gt;invokeMethod($p, 'addFactor', [6]);</p>
<p>   $this-&gt;assertTrue($p-&gt;isPerfect());<br />
}[/code]<br />
И сам метод.</p>
<p>[code lang="php"]public function isPerfect()<br />
{<br />
   return $this-&gt;sumOfFactors() - $this-&gt;number == $this-&gt;number;<br />
}</p>
<p>protected function sumOfFactors()<br />
{<br />
   return array_reduce($this-&gt;factors, function ($carry, $item) {<br />
       return $carry + $item;<br />
   }, 0);<br />
}[/code]<br />
У нас появился метод sumOfFactors, но он достаточно тривиален. Поэтому не будем покрывать его тестами.</p>
<p>Теперь нужно протестировать лишь два аспекта: генерацию списка делителей и проверку на корректность на нескольких совершенных числах.</p>
<p>[code lang="php"]public function testFactorsFor6()<br />
{<br />
   $expected = [1, 2, 3, 6];<br />
   $p = new PerfectNumber(6);<br />
   $this-&gt;assertEquals($expected, $p-&gt;getFactors(), &quot;&quot;, 0.0, 10, true);<br />
}[/code]<br />
Реализуем аспект генерации списка делителей.</p>
<p>[code lang="php"]public function __construct($number)<br />
{<br />
   $this-&gt;number = $number;<br />
   $this-&gt;factors = [];</p>
<p>   $this-&gt;addFactor(1);<br />
   $this-&gt;addFactor($number);<br />
   $this-&gt;calculateFactors();<br />
}</p>
<p>protected function calculateFactors()<br />
{<br />
   for ($i = 2; $i &lt; sqrt($this-&gt;number) + 1; $i++) {<br />
       $this-&gt;addFactor($i);<br />
   }<br />
}[/code]<br />
Почему мы генерируем список делителей в конструкторе? Потому что это одно из следствий требования иммутабельности.</p>
<p>Самый последний тест должен работать без каких-либо правок кода. Он покажет нам, что все работает корректно.</p>
<p>[code lang="php"]public function testIsPerfect()<br />
{<br />
   $p = new PerfectNumber(6);<br />
   $this-&gt;assertTrue($p-&gt;isPerfect());</p>
<p>   $p = new PerfectNumber(7);<br />
   $this-&gt;assertFalse($p-&gt;isPerfect());<br />
}[/code]<br />
Полный код проекта вы найдете в каталоге <i>lesson_01/perfect_number_tdd</i>.</p>
<h2>Выводы</h2>
<p>Сравнивая два варианта кода, легко заметить, что TDD-версия длиннее, но при этом разбита на множество мелких методов. Глядя на эти методы вы ясно представляете, что делается и какой ожидаемый результат.</p>
<p>По прошествию какого-то времени, когда потребуется внести изменения в код, вы сможете вносить изменения с уверенностью в том, что ничего не поломается. Если что-то и случится, то среди коротких методов всегда легко отыскать причину, а тесты всегда вам подскажут, где и что сломалось (вспомните момент, когда вы добавляли в список делителей само число). Если же ваш код - это множество длинных методов, то изолировать ошибку очень и очень сложно (вам придется долгими бессонными ночами сидеть с отладчиком, либо ставить var_dump в коде в разных местах). Запомните: если в код метода надо вставлять комментарии - значит это плохой метод и его можно сделать лучше, а стороннему разработчику потребуется очень много времени на то, чтобы вникнуть в суть работы этого кода.</p>
<h3><b>Дизайн системы</b></h3>
<p>Положительное влияние на общее качество дизайна системы - это еще одна неоспоримая особенность TDD. Предположим, что новым требованием руководства стало нахождение не только совершенных, но и чисел, у которых сумма делителей меньше или больше самого числа. В случае одной монолитной функции придется внести в код побочные эффекты, что крайне негативно сказывается на его качестве, либо разбивать один метод на множество мелких, которые будет чем-то напоминать tdd-версию.</p>
<p>А так достаточно будет просто добавить два метода.</p>
<p>[code lang="php"]public function isDeficient()<br />
{<br />
    return $this-&gt;sumOfFactors() - $this-&gt;number &gt; $this-&gt;number;<br />
}</p>
<p>public function isAbundand()<br />
{<br />
    return $this-&gt;sumOfFactors() - $this-&gt;number &lt; $this-&gt;number;<br />
}[/code]<br />
Все есть. TDD-код часто состоит из таких элементов, использовать которые повторно очень и очень просто.</p>
<p>Подводя итоги. Преимущества TDD перед стандартным способом написания кода:</p>
<ul>
<li>Код создается с учетом потребителей, так как первым потребителем является ваш тест.</li>
<li>Тесты для тривиальных случаев позволяют вовремя выяснить, что нарушена какая-либо критическая зависимость или инфраструктурный компонент.</li>
<li>Важно тестировать граничные условия и особые случаи. Если какой-либо аспект сложно протестировать, то следует его привести к более простому виду (сложность уже говорит о неправильном проектировании). Если не удается упростить, то тесты должны быть как можно более тщательными. Сложный элемент нужно тестировать более тщательно.</li>
<li>Тесты нужно всегда использовать как часть инфраструктуры сборки проекта. Так как самые болезненные и трудно уловимые ошибки чаще всего возникают при внесении изменений в совершенно другие участки кода. Прогон всех блочных тестов нужно осуществлять перед каждой сборкой проекта.</li>
<li>Наличие блочных тестов позволяет проводить более агрессивное изменение кода. А также делает его более открытым для экспериментов вида "а что если". Ведь любое объемное изменение всегда будет проверено.</li>
</ul>
<h2>Литература</h2>
<ul>
<li><a href="http://www.ozon.ru/context/detail/id/136427568/?partner=russianpenguin&amp;from=bar">"Искусство тестирования программ" Гленфорд Майерс, Том Баджетт, Кори Сандлер, ISBN: 978-5-8459-1974-8</a></li>
<li><a href="http://www.ozon.ru/context/detail/id/4434288/?partner=russianpenguin&amp;from=bar">"Продуктивный программист. Как сделать сложное простым, а невозможное - возможным" Нил Форд, ISBN: 978-5-93286-156-1</a></li>
</ul>
<h2>Исходный код</h2>
<ul>
<li><a href="https://github.com/RussianPenguin/TDD/tree/master/03">GitHub</a></li>
</ul>
<h2><a href="http://russianpenguin.ru/%d1%82%d0%b5%d1%81%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d0%bf%d0%be/">Оглавление</a></h2>
