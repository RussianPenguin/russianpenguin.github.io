---
layout: post
title: Несколько советов по оптимизации приложений на Angular JS
date: 2014-10-20 21:14:53.000000000 +04:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Разработка
tags:
- angularjs
- javascript
meta:
  _wpcom_is_markdown: '1'
  sharing_disabled: '1'
  _wpas_skip_facebook: '1'
  _wpas_skip_google_plus: '1'
  _wpas_skip_twitter: '1'
  _wpas_skip_linkedin: '1'
  _wpas_skip_tumblr: '1'
  _wpas_skip_path: '1'
  _publicize_pending: '1'
  _edit_last: '13696577'
  _rest_api_published: '1'
  _rest_api_client_id: "-1"
  _oembed_d4fc86ba36c5d58422b8428062fe82f2: "{{unknown}}"
  _oembed_8d8898db6faec6d658e4ffd1c8642fd8: "{{unknown}}"
  _oembed_e9c1ea648f272ef43d2a641288e6ea39: "{{unknown}}"
author:
  login: russianpenguin
  email: maksim.v.zubkov@gmail.com
  display_name: russianpenguin
  first_name: Maksim
  last_name: Zubkov
permalink: "/2014/10/20/%d0%bd%d0%b5%d1%81%d0%ba%d0%be%d0%bb%d1%8c%d0%ba%d0%be-%d1%81%d0%be%d0%b2%d0%b5%d1%82%d0%be%d0%b2-%d0%bf%d0%be-%d0%be%d0%bf%d1%82%d0%b8%d0%bc%d0%b8%d0%b7%d0%b0%d1%86%d0%b8%d0%b8-%d0%bf%d1%80%d0%b8/"
---
<h2>Что нам потребуется.</h2>
<h3>AngularJS</h3>
<p>Версия &lt; 1.3</p>
<p>В версии 1.3 появились существенные отличия. Включая однонаправленный биндинг - :: (два двоеточия), но она несовместима с bindonce.</p>
<p>Хотя по скорости ничем не уступает оптимизированному варианту. Если вы используете &gt;= 1.3, то применяйте готовый однонаправленный биндинг вместо bo-*</p>
<h3>Bindonce</h3>
<p>url: <a title="Bindonce" href="https://github.com/Pasvaz/bindonce">https://github.com/Pasvaz/bindonce</a></p>
<p>Эта библиотека позволяет делать однонаправленный биндинг данных в шаблоны.<br />
Если вам не требуется, чтобы какая-то переменная после своего отображения меняла значение (т.е. она не будет его менять в процессе работы), то это однозначно для вас.</p>
<p>Например у нас есть список книг, который приходит с сервера и обновляется целиком (опять же с сервера).<br />
Что мы делаем в коде</p>
<p>[code lang="html"]&lt;div ng-repeat=&quot;book in books&quot;&gt;&lt;span&gt;{{book.name}}&lt;/span&gt;&lt;div&gt;[/code]</p>
<p>Имя книги не меняется и мы можем записать так</p>
<p>[code lang="html"]&lt;div ng-repeat=&quot;book in books&quot;&gt;&lt;span bo-text=&quot;book.name&quot;&gt;&lt;/span&gt;&lt;div&gt;[/code]</p>
<p>Так как при перезагрузке книг список books будет изменен полностью, то дерево будет перестроено заново и нам не нужно никак заботиться о том, что имя изменится.</p>
<p>Однако, если вы используете sly-repeat (ниже), то его нельзя сочетать с bindonce из-за агрессивного кеширования дерева дом этим самым слайрепитом.</p>
<h3>Scalyr</h3>
<p>url: <a title="Scalyr" href="https://github.com/scalyr/angular">https://github.com/scalyr/angular</a></p>
<p>post: <a title="Blogpost about scalyr" href="http://blog.scalyr.com/2013/10/31/angularjs-1200ms-to-35ms/">http://blog.scalyr.com/2013/10/31/angularjs-1200ms-to-35ms/</a></p>
<p>Эта библиотека позволит вам минимизировать количество одновременно работающих вотчеров путем отключения ненужных. А так же реализовать умный ng-repeat с кешированием созданных dom-элементов (который, увы, не сильно дружит с bindonce. т.е. не дружит вовсе).</p>
<h2>Оптимизации</h2>
<h3>Много скрытых элементов на странице</h3>
<p>Это одна из ключевых оптимизаций для проекта. Так как нам часто приходится скрывать/показывать разные элементы.</p>
<p>Представим, что у нас есть какой-то код типа нижеследующего.</p>
<p>[code lang="html"]&lt;div ng-show=&quot;condition&quot;&gt;&lt;!-- а тут много разных строчек с данными, которые выводятся на базе данных из ангуляра --&gt;&lt;/div&gt;[/code]</p>
<p>Если не предпринять дополнительных действий, то все то, что написано внутри скрытого дива будет выполняться (!), а это лишние такты процессора и нервные подергивания пользователя.</p>
<p>Что же мы можем сделать?</p>
<p>На помощь нам приходит sly-show+sly-prevent-evaluation-when-hidden. Эта убойная комбинация не будет запускать интерпретацию скрытых элементов.</p>
<p>[code lang="html"]&lt;div sly-show=&quot;condition&quot; sly-prevent-evaluation-when-hidden&gt;&lt;!-- а тут много разных строчек с данными, которые выводятся на базе данных из ангуляра --&gt;&lt;/div&gt;[/code]</p>
<p>Переписав код таким образом мы получим тот самый профит: снижение нагрузки на клиент-сайд.</p>
<p>Но стоит заметить одну особенность директивы: она в своем решении интерпретировать или нет вложенный код опирается на наличие класса ng-hide. При инициализации приложения или перерисовке элементов этого класса нет. Поэтому мы можем увидеть что-то вроде этого:</p>
<p><a href="https://russianpenguin.files.wordpress.com/2014/10/d0b2d18bd0b4d0b5d0bbd0b5d0bdd0b8d0b5_092.png"><img class="aligncenter size-medium wp-image-370" src="{{ site.baseurl }}/assets/images/2014/10/d0b2d18bd0b4d0b5d0bbd0b5d0bdd0b8d0b5_092.png?w=300" alt="Trace angular application" width="300" height="186" /></a></p>
<p>Причина проста: у элементов при инициализации еще нет класса ng-hide. Он появится только после того, как отработают нужны контроллеры, а значит, что отрисовка элемента с нуля всегда будет отрисовывать и интерпретировать все скрываемые элементы (даже если они действительно скрыты).</p>
<p>Решение проблемы: принудительно добавить класс ng-hide всем элементам, которые находятся под связкой sly-show+sly-prevent-evaluation-when-hidden.</p>
<p>[code lang="html"]&lt;div class=&quot;ng-hide&quot;&gt;&lt;!-- а тут много разных строчек с данными, которые выводятся на базе данных из ангуляра --&gt;&lt;/div&gt;[/code]</p>
<p>На этом оптимизация неиспользуемого кода закончена.</p>
<h3>Оптимизация биндингов</h3>
<p>Под этим подразумевается однократное добавление в шаблон переменной.</p>
<p>Как в примере bindonce с книгами (выше) нам может не требоваться функционал двунаправленного отображения.</p>
<p>Поэтому все подобные участки мы заменяем однонаправленным биндингом.</p>
<pre>{{var}} -&gt; &lt;div bo-text=”var”&gt;&lt;/div&gt;</pre>
<div></div>
<p>Путь оптимизации: вместо элемента создается контейнер, на который выполняется отображение текста элемента. Так как в биндванс не существует шаблонной конструкции для биндинга. Естественно, что там может быть любой тег и не обязательно div. Самое главное - наличие контейнера.</p>
<pre>ng-href="text{{var}}" -&gt; bo-href="’text’ + var"</pre>
<p>А так мы оптимизировали ссылки.<br />
Важно заметить, что ng-* и bo-* работают с биндингами различным образом: если первый работает по внутриангуляровским правилам интепретации, то второй просто выполняет .eval() на строку. Поэтому в bo-* мы работаем с обычными строками и переменными.</p>
<p>Аналогичным образом работаем и с другими атрибутами. Если есть аналог биндинга.</p>
<p>Если аналога нет, то используем конструкцию bo-attr-&lt;имя кастомного атрибута&gt;</p>
<p>[code lang="html"]&lt;div bo-attr bo-attr-isbn=&quot;’{{book.isbn}}’&quot;&gt;&lt;/div&gt;[/code]</p>
<p>Здесь кроется еще одна важная особенность обработки атрибутов библиотекой: они рассматриваются как строки. И если в атрибуте текст, что его надо представить в виде текста (то же характерно для любого юиндига bo-*). Мы привыкли чаще всего работать с числами, но не стоит забывать, что есть еще буквы.</p>
<p>Поэтому если не уверены в содержимом переменной - пишите строковое предствление: <em>‘{{var}}’</em>, а не <em>var</em>.</p>
<h3>Вложенность элементов</h3>
<p>На картинке профайлера (выше) вы можете увидеть гребенку из кучи вложенных вызовов функций. Если мы посмотрим на эти вывовы под микроскопом отладчиком, то увидим, что это рекурсивный обход дерева dom.</p>
<p>Чем меньше у вас уровней вложенности, тем лучше. Особенно это касается кода, который расположен в циклах.</p>
<p>Так что старайтесь сократить вложенности.</p>
<h3>Дополнительная оптимизация при обработке скрытых элементов</h3>
<p>У sly-prevent-evaluation-when-hidden есть одна большая проблема: она опирается только на наличие класса ng-hide, что не совсем уместно если видимость элемента контролируется каким-то другим классом.</p>
<p>В таком случае можно (вообще нужно всегда) использовать следующее расширение директивы (подключаем после подключения scalyr).</p>
<p>[code lang="javascript"]/**<br />
* Extended version of slyPreventEvaluationWhenHidden from scalyr.<br />
* This version prevent evaluation not only when element has class ng-hide.<br />
* If element is hidden with &quot;display: none&quot; evaluation is prevented.<br />
*/<br />
angular.module('sly')<br />
 .directive('slyPreventEvaluationWhenHidden', function () {<br />
   return {<br />
     restrict: 'A',<br />
     // We create a new scope just because it helps segment the gated watchers<br />
     // from the parent scope.  Unclear if this is that important for perf.<br />
     scope: true,<br />
     compile: function compile(tElement, tAttrs) {<br />
       return {<br />
         // We need a separate pre-link function because we want to modify the scope before any of the<br />
         // children are passed it.<br />
         pre: function preLink(scope, element, attrs) {<br />
           scope.$addWatcherGate(function hiddenChecker() {<br />
             // Should only return true if the element is not hidden.<br />
             return !element.hasClass('ng-hide') &amp;&amp; element.is(&quot;:visible&quot;) ;<br />
           }, function hiddenDecider(watchExpression, listener, equality, directiveName) {<br />
             // Make an exception for slyShow.. do not gate its watcher.<br />
             if (isDefined(directiveName) &amp;&amp; (directiveName == 'slyShow'))<br />
               return false;<br />
             return true;<br />
           });<br />
         },<br />
       };<br />
     },<br />
   };<br />
 });[/code]</p>
