---
layout: post
title: 'Kinect: избавляемся от искажений при помощи потолка'
date: 2014-11-16 21:22:20.000000000 +03:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- JFF
- kinect
tags:
- обработка изображений
meta:
  _wpcom_is_markdown: '1'
  sharing_disabled: '1'
  _wpas_skip_facebook: '1'
  _wpas_skip_google_plus: '1'
  _wpas_skip_twitter: '1'
  _wpas_skip_linkedin: '1'
  _wpas_skip_tumblr: '1'
  _wpas_skip_path: '1'
  _publicize_pending: '1'
  _rest_api_published: '1'
  _rest_api_client_id: "-1"
  _edit_last: '13696577'
author:
  login: russianpenguin
  email: maksim.v.zubkov@gmail.com
  display_name: russianpenguin
  first_name: Maksim
  last_name: Zubkov
permalink: "/2014/11/16/kinect-%d0%b8%d0%b7%d0%b1%d0%b0%d0%b2%d0%bb%d1%8f%d0%b5%d0%bc%d1%81%d1%8f-%d0%be%d1%82-%d0%b8%d1%81%d0%ba%d0%b0%d0%b6%d0%b5%d0%bd%d0%b8%d0%b9-%d0%bf%d1%80%d0%b8-%d0%bf%d0%be%d0%bc%d0%be%d1%89%d0%b8/"
---
<p><a href="https://russianpenguin.files.wordpress.com/2014/11/d180d0b0d0b1d0bed187d0b5d0b5-d0bcd0b5d181d182d0be-2_125.png"><img class="alignleft wp-image-465 size-thumbnail" src="{{ site.baseurl }}/assets/images/2014/11/d180d0b0d0b1d0bed187d0b5d0b5-d0bcd0b5d181d182d0be-2_125.png?w=150" alt="Идеально плоский потолок" width="150" height="84" /></a>Давеча я <a title="Kinect: о восстановлении координат и абберациях разного рода" href="http://russianpenguin.ru/2014/11/16/kinect-%D0%BE-%D0%B2%D0%BE%D1%81%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B8-%D0%BA%D0%BE%D0%BE%D1%80%D0%B4%D0%B8%D0%BD%D0%B0%D1%82-%D0%B8-%D0%B0%D0%B1%D0%B1%D0%B5%D1%80%D0%B0/">писал</a> про то, как выглядят данные, которые приходят с сенсора. Такое поведение сенсора просто возмутительно и долго это продолжаться не может.</p>
<p>Ок. А что нам потребуется? Нам потребуется потолок. Я внимательно его осмотрел и убедился, что в реальности он плоский. А вот на восстановленом изображении - нифига.</p>
<p>Для начала нам нужно сохранить дамп глубин "идеального" потолка. Можно и стену если у вас есть достаточно плоской поверхности. :)</p>
<p>В файл будет сохранена двумерная матрица из чисел разделенных пробелами. Строки по строкам и т.д. Позже поймем зачем именно так.</p>
<p>Кусочек файла</p>
<pre>888 889 890 890 890 890 890 891 890 891 891 892 892 892 892 892 892 892 892 892 891 893 892 892 892 892 892 ... 2047 2047 2047 2047 2047 2047
...</pre>
<p>Теперь посмотрим на картинку этой самой плоскости. Для этого запускаем <a title="Maxima, a Computer Algebra System" href="http://maxima.sourceforge.net/">maxima.</a></p>
<p>[code](%i1) load(numericalio);<br />
(%i2) m: read_matrix(&amp;quot;&amp;lt;путь к файлу с глубинами&amp;gt;&amp;quot;);<br />
($i3) f(x, y) := float('m [round(x), round(y)]);<br />
-- тут мы зададим функцию извлечения нужного значения из матрицы.<br />
-- Так как матрица наши данные дискретны<br />
-- и существуют только в определенных точках<br />
(%i4) plot3d (f(x, y), [x, 1, 640], [y, 1, 480]);[/code]</p>
<p>О! Круто. Мы что-то видим.</p>
<p><a href="https://russianpenguin.files.wordpress.com/2014/11/d0b2d18bd0b4d0b5d0bbd0b5d0bdd0b8d0b5_124.png"><img class="aligncenter wp-image-463 size-medium" src="{{ site.baseurl }}/assets/images/2014/11/d0b2d18bd0b4d0b5d0bbd0b5d0bdd0b8d0b5_124.png?w=300" alt="Потолок. Необработанная карта глубин" width="300" height="170" /></a></p>
<p>Что-то не то :)</p>
<p>Стоит заметить, что в режиме сырых данных FREENECT_DEPTH_11BIT самые правые 8 столбцов не используются и всегда возвращают значение FREENECT_DEPTH_RAW_MAX_VALUE. Об этом не стоит забывать при последующих действиях.</p>
<p>Поэтому нам нужно посмотреть плоскость без правых столбцов (8 штук).</p>
<p>[code](%i4) plot3d (f(x, y), [x, 1, 632], [y, 1, 480]);[/code]</p>
<p>И тут уже то, что нам надо.</p>
<p><a href="https://russianpenguin.files.wordpress.com/2014/11/d0b2d18bd0b4d0b5d0bbd0b5d0bdd0b8d0b5_123.png"><img class="aligncenter wp-image-464 size-medium" src="{{ site.baseurl }}/assets/images/2014/11/d0b2d18bd0b4d0b5d0bbd0b5d0bdd0b8d0b5_123.png?w=300" alt="Потолок: карта глубин после доработки" width="300" height="164" /></a>Это плоскость. Но не очень плоская. И таки да. Надо сделать ее обратно плоской. :)</p>
<p>Мы знаем, что все точки данной поверхности равноудалены от плоскости, где расположен сенсор.</p>
<p>Поэтому можно ввести коэффициент нормировки для каждой из точек (x, y). Который будет равен отношению реального расстояния к полученному.</p>
<p>Зная этот коэффициент можно узнать, реальное расстояние до точки. Просто умножив полученное от кинекта значение на коэффициент нормировки в данной точке (x, y).</p>
<p>Коэффициенты считаем один раз по калибровочному изображению. А затем загружаем в свое приложение и пользуемся.</p>
<p>Минусы решения</p>
<ul>
<li>Я предположил, что коэффициент нормировки зависит только от координат (x, y), но не зависит от глубины. Так это или нет - проверю. (пока датчик говорит, что я прав)</li>
<li>Плоскость по которой выполняется калибровка должна находится на расстоянии 2,5-3,5 метров от сенсора. Именно при таком положении коэффициенты нормировки будет точными.</li>
<li>Так как сенсор довольно чувствителен, то его положение должно быть параллельно плоскости калибровки (мне помогал обычный строительный уровень)</li>
<li>Так же перед калибровкой полученное изображение плоскости нужно сгладить для того, чтобы избавиться от шумов (это умеет делать матлабоский <a title="Matlab: smoothn" href="http://www.biomecardio.com/matlab/smoothn.html#11">smoothn</a>)</li>
</ul>
<p><strong>UPD</strong></p>
<p><a title="Kinect depth view with Ogre3d" href="https://github.com/RussianPenguin/kinectDepthView">Код на гитхабе</a></p>
