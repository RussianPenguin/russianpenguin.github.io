---
layout: post
title: 'Часть 6: Самописный тестовый фреймворк (Тестирование ПО)'
date: 2017-05-14 21:26:06.000000000 +03:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Разработка
- HowTo
tags:
- mysql
- тестирование по
- phpunit
- yii2
meta:
  _wpcom_is_markdown: '1'
  _rest_api_published: '1'
  _rest_api_client_id: "-1"
  _publicize_job_id: '5040485788'
author:
  login: russianpenguin
  email: maksim.v.zubkov@gmail.com
  display_name: russianpenguin
  first_name: Maksim
  last_name: Zubkov
permalink: "/2017/05/14/%d1%82%d0%b5%d1%81%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d0%bf%d0%be-%d1%87%d0%b0%d1%81%d1%82%d1%8c-6/"
excerpt: В шестой части цикла тестирование ПО мы разберемся с тем как устроены тестовые
  фреймворки изнутри.
---
<h2><img class=" size-full wp-image-2103 alignleft" src="{{ site.baseurl }}/assets/images/2017/05/00-intro.png" alt="00-intro" width="224" height="142" /><a href="http://russianpenguin.ru/%d1%82%d0%b5%d1%81%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d0%bf%d0%be/">Оглавление</a></h2>
<p>Продолжаем цикл статей <a href="http://russianpenguin.ru/%d1%82%d0%b5%d1%81%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d0%bf%d0%be/">Тестирование ПО</a> в котором рассказывается о разработке программного обеспечения с применением методологии TDD.</p>
<p>Прежде всего, равно как и в <a href="http://russianpenguin.ru/2017/04/09/%d1%82%d0%b5%d1%81%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d0%bf%d0%be-%d1%87%d0%b0%d1%81%d1%82%d1%8c-2/">одной из предыдущих лекции</a>, нам надо разобраться как тесты работают изнутри. И только лишь после этого мы сможем их успешно применять.</p>
<p><!--more--></p>
<h2>Стандарты кодирования</h2>
<p>Прежде чем вы напишите хоть строчку кода нужно установить и настроить механизм, который будет проверять ваш код на соответствие общепринятым или локальным стандартам. Никогда не пишите код без подобных проверок. Этим вы убережете себя или ваших коллег от множества проблем.</p>
<p>Поскольку мы пишем на Yii2, то и стандарт у нас будет соответствующим: <a href="https://github.com/yiisoft/yii2-coding-standards">Yii 2 Web Framework Coding Standard</a>.</p>
<p>Чтобы иметь возможность проверять код нам потребуется дополнительный инструмент под названием <a href="https://github.com/squizlabs/PHP_CodeSniffer">PHP CodeSniffer</a>.</p>
<p>Для установки нужных компонент добавляем в секцию require-dev файла composer.json следующие записи:</p>
<p>[code lang="javascript"]&quot;yiisoft/yii2-coding-standards&quot;: &quot;2.0.*&quot;,<br />
&quot;squizlabs/php_codesniffer&quot;: &quot;2.*&quot;[/code]<br />
Затем зайдя по ssh на виртуальную машину выполняем в каталоге /var/www команду</p>
<p>[code]composer update[/code]</p>
<p><img class=" size-full wp-image-2060 aligncenter" src="{{ site.baseurl }}/assets/images/2017/05/01-composer-json.png" alt="01-composer.json" width="350" height="204" /></p>
<p>После завершения нам будет доступен codesniffer. И не забывайте закоммитить изменения composer.lock в вашу систему контроля версий.</p>
<p>Для проверки кода на соблюдение стандартов в консоли виртуальной машины (в каталоге /var/www) запускаем команду</p>
<p>[code]composer exec --verbose -- phpcs --extensions=php --standard=./vendor/yiisoft/yii2-coding-standards/Yii2 &lt;путь к файлу или папке, который требуется проверить&gt;[/code]</p>
<p><img class=" size-full wp-image-2063 aligncenter" src="{{ site.baseurl }}/assets/images/2017/05/02-phpcs.png" alt="02-phpcs" width="775" height="756" /></p>
<p>Примите за правило: всегда запускать подобные проверки для вашего кода и исправлять то, что не соответствует стандартам. Идеальной будет ситуация когда у вас нет несоответствия правилам кодирования.</p>
<h2>Валидация модели пользователя</h2>
<p>Мы уже разобрались с тем, как работают миграции. Теперь посмотрим на модель пользователя. Она расположена в файле <i>common/models/User.php</i>. Конечно же потребуется ее доработать.</p>
<p>Что какие свойства пользователя являются необходимыми для его существования?</p>
<ul>
<li>уникальность почтового адреса</li>
<li>наличие пароля</li>
<li>наличие ника пользователя (username)</li>
<li>уникальность хеша для сброса пароля (password_reset_token)</li>
</ul>
<p>Эти соблюдение этих правил говорит нам о том, что при работе с моделью (и внутри модели) нет ошибок.</p>
<p>Ошибка многих начинающих и не очень разработчиков в том, что они пытаются организовать уникальность пользователя через ник, что в корне неверно. Это заблуждение порождает шедевры вроде "Ромашка_227" и иные, не менее странные, вещи.</p>
<p>В шаблоне проекта уже есть папка <i>common/tests</i>. Ее содержимое нам не пригодится. Поэтому можем смело его удалять и оставлять папку пустой.</p>
<p>Напишем наш первый тест.</p>
<p><b>common/tests/unit/UserTest.php</b></p>
<p>[code lang="php"]namespace common\tests\unit;<br />
require_once(__DIR__ . '/../_bootstrap.php');<br />
use common\models\User;</p>
<p>class UserTest<br />
{<br />
   public function testValidateEmptyFields()<br />
   {<br />
       $user = new User();<br />
       echo 'Validate username, password, email (empty case): ';<br />
       if ($user-&gt;validate() === false) {<br />
           echo 'Ok!' . PHP_EOL;<br />
       } else {<br />
           echo 'Fail :(' . PHP_EOL;<br />
       }<br />
       echo 'Check for username errors: ';<br />
       if (array_key_exists('username', $user-&gt;getErrors())) {<br />
           echo 'Ok!' . PHP_EOL;<br />
       } else {<br />
           echo 'Fail :(' . PHP_EOL;<br />
       }<br />
       echo 'Check for email errors: ';<br />
       if (array_key_exists('email', $user-&gt;getErrors())) {<br />
           echo 'Ok!' . PHP_EOL;<br />
       } else {<br />
           echo 'Fail :(' . PHP_EOL;<br />
       }<br />
       echo 'Check for password errors: ';<br />
       if (array_key_exists('password_hash', $user-&gt;getErrors())) {<br />
           echo 'Ok!' . PHP_EOL;<br />
       } else {<br />
           echo 'Fail :(' . PHP_EOL;<br />
       }<br />
   }<br />
}</p>
<p>$test = new UserTest();<br />
$test-&gt;testValidateEmptyFields();[/code]</p>
<p>Код тривиален и в пояснениях не нуждается. Но мы видим, что в файле происходит подключение <em>_bootstrap.php</em>. Посмотрим на него.</p>
<p><b>common/tests/_bootstrap.php</b></p>
<p>[code lang="php"]defined('YII_DEBUG') or define('YII_DEBUG', true);<br />
defined('YII_ENV') or define('YII_ENV', 'test');<br />
require(__DIR__ . '/../../vendor/autoload.php');<br />
require(__DIR__ . '/../../vendor/yiisoft/yii2/Yii.php');<br />
require(__DIR__ . '/../config/bootstrap.php');<br />
require(__DIR__ . '/../../console/config/bootstrap.php');</p>
<p>$config = yii\helpers\ArrayHelper::merge(<br />
   require(__DIR__ . '/../config/test-local.php'),<br />
   require(__DIR__ . '/../../console/config/main.php'),<br />
   require(__DIR__ . '/../../console/config/main-local.php')<br />
);</p>
<p>$application = new yii\console\Application($config);[/code]</p>
<p>Видим, что это не что иное как точка входа для инициализации фреймворка. Подключаются и инициализируются автозагрузка и тестовая конфигурация. Обратите внимание на то, что код подключает конфиг <i>test-local.php</i>, который мы правили ранее. Последней строкой происходит инициализация фреймворка без запуска. В нашем случае нет необходимости выполнять фактический запуск поскольку все происходит внутри теста.</p>
<p>Код первого теста готов. Теперь заходим на виртуальную машину по ssh и в каталоге <i>/var/www</i> запускаем файл кейса на исполнение.</p>
<p>[code]php common/tests/unit/UserTest.php[/code]</p>
<p><img class=" size-full wp-image-2068 aligncenter" src="{{ site.baseurl }}/assets/images/2017/05/03-usertest-fail.png" alt="03-usertest-fail" width="1034" height="161" /></p>
<p>Что это?! Почему мы видим ошибку о том, что какая-то таблица не создана? Все верно, выше было замечено, что используется подключение к тестовой бд. А миграции для тестовой базы мы не применяли, только для базы разработчика.</p>
<p>Это значит, что из консоли виртуальной машины следует выполнить команду, которая применит миграции на тестовую бд.</p>
<p>[code]php yii_test migrate[/code]</p>
<p>Система спросит вас о том, согласны ли вы на применение миграции к бд, а после покажет сообщение об успешном выполнении.</p>
<p>Теперь можно запускать тесты.</p>
<p><img class=" size-full wp-image-2071 aligncenter" src="{{ site.baseurl }}/assets/images/2017/05/04-usertest-ran.png" alt="04-usertest-ran" width="436" height="121" /></p>
<p>Тесты не прошли. Да оно и понятно - отсутствует валидация внутри модели. Поэтому добавим несколько правил в метод <i>User::rules()</i>.</p>
<p>[code lang="php"]public function rules()<br />
{<br />
   return [<br />
       [['username', 'email', 'password_hash'], 'required'],<br />
       [['email'], 'unique'],<br />
       [['username', 'email', 'password_hash'], 'string', 'max' =&gt; 255],<br />
       [['username'], 'match', 'pattern' =&gt; '#^[a-z0-9_-]+$#i'],<br />
       [['email'], 'email'],<br />
       ['status', 'default', 'value' =&gt; self::STATUS_ACTIVE],<br />
       ['status', 'in', 'range' =&gt; [self::STATUS_ACTIVE, self::STATUS_DELETED]],<br />
   ];<br />
}[/code]</p>
<p>Максимальную длину строк мы проверяем на тот случай если база не включена в так называемый "<a href="https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sql-mode-strict">строгий режим</a>", который вызывает исключение всякий раз, когда происходит что-то невообразимое (например мы пытаемся в поле varchar размером 255 записать значение больше 255 символов). Крайне рекомендуется держать базу в строгом режиме и препятствовать его отключению.</p>
<p>Очередной запуск проходит успешно и никаких ошибок мы не нашли.</p>
<p><img class=" size-full wp-image-2075 aligncenter" src="{{ site.baseurl }}/assets/images/2017/05/05-usertest-success.png" alt="05-usertest-success" width="418" height="129" /></p>
<p>Уже заметно, что при увеличении числа проверяемых случаев нам потребуется писать все больше и больше ветвлений. На этом этапе пора задуматься о рефакторинге тестов и вынести методы сравнения результата возвращаемого значения с чем-либо в отдельные функции, переписать соответствующим образом код модуля, вынеся все общие функции в файл <i>TestCase.php</i>.</p>
<p><b>common/tests/TestCase.php</b></p>
<p>[code lang="php"]namespace common\tests;<br />
class TestCase<br />
{<br />
   protected function assertTrue($value, $testName = '')<br />
   {<br />
       $this-&gt;assertEquals(true, $value, $testName);<br />
   }<br />
protected function assertFalse($value, $testName = '')<br />
   {<br />
       $this-&gt;assertEquals(false, $value, $testName);<br />
   }</p>
<p>   protected function assertArrayHasKey($needle, array $haystack, $testName = '')<br />
   {<br />
       $this-&gt;assertTrue(array_key_exists($needle, $haystack), $testName);<br />
   }</p>
<p>   protected function assertEquals($expected, $value, $testName = '')</p>
<p>   {<br />
       printf('%s: ', $testName);<br />
       if ($value === $expected) {<br />
           echo 'ok' . PHP_EOL;<br />
       } else {<br />
           echo 'fail' . PHP_EOL;<br />
       }<br />
   }<br />
}[/code]</p>
<p>Соответствующим образом рефакторим код <em>UserTest.php</em> дабы он использовал новый функционал.</p>
<p><b>common/tests/UserTest.php</b></p>
<p>[code lang="php"]namespace common\tests\unit;</p>
<p>require_once(__DIR__ . '/../_bootstrap.php');</p>
<p>use common\models\User;<br />
use common\tests\TestCase;</p>
<p>class UserTest extends TestCase<br />
{<br />
   public function testValidateEmptyFields()<br />
   {<br />
       $user = new User();<br />
       $this-&gt;assertFalse($user-&gt;validate(), 'Validate username, password, email (empty)');<br />
       $this-&gt;assertArrayHasKey('password_hash', $user-&gt;getErrors(), 'Check for password errors');<br />
       $this-&gt;assertArrayHasKey('email', $user-&gt;getErrors(), 'Check for email errors');<br />
       $this-&gt;assertArrayHasKey('username', $user-&gt;getErrors(), 'Check for username errors');<br />
   }<br />
}</p>
<p>$test = new UserTest();<br />
$test-&gt;testValidateEmptyFields();[/code]</p>
<p>Теперь уже лучше. И, как вы можете заметить, тесты писать стало проще.</p>
<p><img class=" size-full wp-image-2077 aligncenter" src="{{ site.baseurl }}/assets/images/2017/05/06-usertest-refactoring-1.png" alt="06-usertest-refactoring-1" width="369" height="122" /></p>
<p>Закономерный вопрос: "а нужны ли такие простые тесты?". Да. Безусловно нужны. Вы можете забыть создать уникальный ключ по полю email. Может случится такая ситуация, что на новой форме вы сделали одно из полей по требованию заказчика обязательным для ввода, но при этом забыли поставить на него признак unique в модели. Как было отмечено ранее - простые тесты в первую очередь дают возможность выявлять ошибки инфраструктуры на ранней стадии. Добавим еще несколько тестов дабы быть уверенными, что все идет хорошо.</p>
<p>[code lang="php"]public function testEmailFormat()<br />
{<br />
   $user = new User(['email' =&gt; 'sdfsdfsdfsdf', 'username' =&gt; 'username', 'password' =&gt; 123]);<br />
   $this-&gt;assertFalse($user-&gt;validate(), 'Validate username, password, email (incorrect)');<br />
   $this-&gt;assertArrayNotHasKey('password', $user-&gt;getErrors(), 'Check for password errors');<br />
   $this-&gt;assertArrayHasKey('email', $user-&gt;getErrors(), 'Check for email errors');<br />
   $this-&gt;assertArrayNotHasKey('username', $user-&gt;getErrors(), 'Check for username errors');<br />
}[/code]</p>
<p>Чтобы запустить данный тест нам потребуется добавить строку запуска в файле <i>UserTest.php</i> и реализовать метод <i>assertArrayNotHasKey()</i> в классе <i>TestCase</i>. Эти действия вы должны будете сделать самостоятельно.</p>
<p><img class=" size-full wp-image-2080 aligncenter" src="{{ site.baseurl }}/assets/images/2017/05/07-usertest-emailformat.png" alt="07-usertest-emailformat" width="399" height="195" /></p>
<p>Прежде чем перейти к следующему шагу, сделаем небольшой рефакторинг и преобразуем код запуска тестов, вынеся его в файл <i>common/tests/unitSuite.php</i>.</p>
<p><b>common/tests/unitSuite.php</b></p>
<p>[code lang="php"]namespace common\tests;</p>
<p>require __DIR__ . DIRECTORY_SEPARATOR . '_bootstrap.php';</p>
<p>foreach (scandir(__DIR__ . DIRECTORY_SEPARATOR . 'unit') as $item) {<br />
   if (substr($item, -8, 8) == 'Test.php') {<br />
       $className = pathinfo($item, PATHINFO_FILENAME);<br />
       $reflection = new \ReflectionClass('common\tests\unit\\' . $className);<br />
       foreach ($reflection-&gt;getMethods() as $method) {<br />
           if (substr($method-&gt;name, 0, 4) === 'test') {<br />
               $test = new $method-&gt;class;<br />
               printf('%s::%s%s', $method-&gt;class, $method-&gt;name, PHP_EOL);<br />
               $test-&gt;{$method-&gt;name}();<br />
           }<br />
       }<br />
   }<br />
}[/code]</p>
<p>И не забываем удалить строчки с подключением файла <em>_bootstrap.php</em> из файла <em>TestCase.php</em>, а из файла <em>UserTest.php</em> удаляем строки запуска самих тестов. Сделав такую своеобразную точку входа нам можно больше не заботится о том, чтобы запускать тесты вручную. Система все сделает за нас: проверить наличие файлов с тестами, найдет в них все кейсы и запустит их, а в процессе работы будет сообщать о том, прошел кейс или нет.</p>
<p><img class=" size-full wp-image-2083 aligncenter" src="{{ site.baseurl }}/assets/images/2017/05/08-unitsuite.png" alt="08-unitsuite" width="426" height="242" /></p>
<h2>Добавление пользователя в базу</h2>
<p>Сейчас мы реализовали некоторый объем тестов для проверки корректности валидации модели. Следующим этапом у нас выступает проверка корректности работы модели с базой. Взаимодействие с базой - это также очень важный атрибут тестирования. Ведь могут проходить все проверки, успешно создаваться экземпляр модели пользователя, но вот только записи в базе после сохранения почему-то не окажется. И очень плохо, когда эти ошибки отлавливают пользователи проекта видя, что товар не добавился в корзину, пост не опубликовался, а что еще хуже - банковская транзакция не была завершена до конца: деньги сняли, а на счет потребителя они не пришли потому что ошибка не была обнаружена разработчиками еще на этапе разработки.</p>
<p>[code lang="php"]public function testAddUser()<br />
{<br />
   $user = new User(['email' =&gt; 'test@test.test', 'username' =&gt; 'admin', 'password' =&gt; 'admin']);<br />
   $user-&gt;generateAuthKey();<br />
   $this-&gt;assertTrue($user-&gt;validate());<br />
   $user-&gt;save();<br />
   $this-&gt;assertTrue(1 == User::find()-&gt;where(['email' =&gt; 'test@test.test'])-&gt;count());<br />
}[/code]</p>
<p>Запускаем. И оно нашло нам первую ошибку.</p>
<p>[code]Exception 'yii\db\Exception' with message 'SQLSTATE[22007]: Invalid datetime format: 1292 Incorrect datetime value: '1494530847' for column 'created_at' at row 1[/code]</p>
<p><img class="alignnone size-full wp-image-2086" src="{{ site.baseurl }}/assets/images/2017/05/09-timestamp-fail.png" alt="09-timestamp-fail" width="934" height="147" /></p>
<p>Происходить это из-за того, что в одной из предыдущих частей проектируя базу данных мы задали поля <i>created_at</i> и <i>updated_at</i> как поля типа <i>timestamp</i>. Этот тип данных хранит временную отметку с таймзоной, которая установлена на машине по-умолчанию.</p>
<h2>Немного о датах и типах полей</h2>
<p>D mysql существует несколько типов календарных полей (типы, которые позволяют хранить временные отметки).</p>
<table>
<tbody>
<tr>
<td><strong>Спецификация типа</strong></td>
<td><strong>Диапазон</strong></td>
<td><strong>Примечания</strong></td>
</tr>
<tr>
<td>DATE</td>
<td>От '1000-01-01' до '9999-12-31'</td>
<td>Хранит дату в формате YYYY-MM-DD "как есть" без сохранения сведений о часовом поясе</td>
</tr>
<tr>
<td>TIME</td>
<td>От '-838:59:59' до '838:59:59'</td>
<td>Хранит смещение от 00:00. Этим и объясняется столь широкий диапазон хранимых данных.</td>
</tr>
<tr>
<td>DATETIME</td>
<td>От '1000-01-01 00:00:00' до '9999-12-31 00:00:00'</td>
<td>Аналогично DATE, но только дополнительно хранит временную отметку в формате hh:mm:ss</td>
</tr>
<tr>
<td>TIMESTAMP([M])</td>
<td>От '1970-01-01 00:00:00' до неопределенной даты в 2037 году</td>
<td>Поле хранит время в часовом поясе UTC. При записи поле конвертируется из часового пояса подключившегося клиента (или сервера) в UTC и при чтении конвертируется из UTC в часовой пояс соответственно настройкам клиента.</td>
</tr>
<tr>
<td>YEAR([M])</td>
<td>От 1901 до 2155 для YEAR(4) и от 1970 до 2069 до YEAR(2)</td>
<td>Хранение данных аналогично DATE. без привязки к часовому поясу.</td>
</tr>
</tbody>
</table>
<p>В соответствии со спецификацией ISO 8601 все даты представляются в формате <i>YYYY-MM-DD [hh:mm:ss]</i>.</p>
<p>При работе с полями типа <i>DATE</i>, <i>DATETIME</i> и <i>YEAR</i> стоит быть очень внимательным так как информация о часовом поясе отсутствует. В современных приложения хорошей практикой является хранить в этих полях данные в часовом поясе UTC, а на клиенте отображать данные в соответствии с его часовым поясом.</p>
<p>Тип поля TIMESTAMP не рекомендуется использовать для хранения данных клиента. Этот тип чаще всего является служебным и хранит автоматически проставляемые временные отметки. Такие как время создания и обновления записи. Старайтесь никогда не писать в подобные поля из клиентского кода, любое их изменение должно проводится триггерами <i>ON UPDATE</i> и <i>ON INSERT</i>. Помимо прочего это поле обладает самым малым диапазоном хранимых данных и уже совсем скоро (на дворе 2017й года) принесет кучу проблем для поставщиков программного обеспечения (проблема 2037 года). Более подробно вы можете ознакомиться с данными типа в книге <a href="http://www.ozon.ru/context/detail/id/3059177/?partner=russianpenguin&amp;from=bar">MySQL</a> от Поля Дюбуа.</p>
<p>Отлично, мы немного прояснили для себя как устроено хранение календарных данных в MySQL, но как это поможет нам исправить ошибку? Это довольно просто - нужно удалить <em>TimestampBehavior</em> из класса <em>User</em>.</p>
<p>Компоненты в Yii2 имеют возможность подключать так называемые "<a href="http://www.yiiframework.com/doc-2.0/guide-concept-behaviors.html">поведения</a>". Иными словами это операции, которые выполняются с объектом при наступлении определенных событий. Модель ActiveRecord - это тоже компонент и она имеет возможность работать с этим аспектом. Одной из таких надстроек является <em>TimestampBehavior</em>, которая обновляет содержимое полей <i>updated_at</i> и <i>created_at</i> при операциях создания или обновления записи. Мы же условились работать с календарными типами данных. Поэтому это поведение следует исключить из метода behaviors().</p>
<p>[code lang="php"]public function behaviors()<br />
{<br />
   return [];<br />
}[/code]</p>
<p>Теперь тест проходит вполне успешно.</p>
<p><img class=" size-full wp-image-2090 aligncenter" src="{{ site.baseurl }}/assets/images/2017/05/10-timestamp-ok.png" alt="10-timestamp-ok" width="424" height="283" /></p>
<p>Однако при повторном запуске теста на ожидает проблема. Тест не проходит. И это очевидно так как первый запуск теста добавил в базу данных пользователя, а повторный пытается добавить этого пользователя снова.</p>
<p><img class=" size-full wp-image-2093 aligncenter" src="{{ site.baseurl }}/assets/images/2017/05/11-adduser-fail.png" alt="11-adduser-fail" width="435" height="293" /></p>
<p>Очевидно, что нужно предусмотреть какой-то способ настройки окружения перед запуском тестов. Назовем его <i>setUp()</i> и исправим код запуска тестов в файле <i>unitSuite.php</i> и код класса <i>TestCase</i>.</p>
<p><b>unitSuite.php</b></p>
<p>[code lang="php"]if (substr($method-&gt;name, 0, 4) === 'test') {<br />
   /**<br />
    * @var TestCase<br />
    */<br />
   $test = new $method-&gt;class;<br />
   printf('%s::%s%s', $method-&gt;class, $method-&gt;name, PHP_EOL);<br />
   $test-&gt;setUp();<br />
   $test-&gt;{$method-&gt;name}();<br />
}[/code]</p>
<p>Обратите внимание на то, что мы добавили doc-комментарий, указывающий тип переменной $test - это позволяет различным ide правильно автодополнять методы этого класса.</p>
<p><b>TestCase</b></p>
<p>[code lang="php"]class TestCase<br />
{<br />
   // other code<br />
/**<br />
    * Execute before every test<br />
    */<br />
   public function setUp()<br />
   {<br />
       // pass<br />
   }<br />
}[/code]</p>
<p>Теперь можно реализовать очистку таблицы user перед запуском каждого теста.</p>
<p><b>UserTest</b></p>
<p>[code lang="php"]public function setUp()<br />
{<br />
   \Yii::$app-&gt;db-&gt;createCommand()-&gt;truncateTable('{{%user}}')-&gt;execute();<br />
}[/code]</p>
<p>Конечно не все тесты были реализованы. Попробуйте в качестве упражнения реализовать тесты на поиск и удаление пользователей. Отметим, что в базе не происходит физического удаления записи о пользователе. Просто поле status устанавливается в значение <i>User::STATUS_DELETED</i>. Помните этот момент при реализации ваших тестов.</p>
<h2>Обеспечение безопасности</h2>
<p>Прежде чем перейти к изучению других аспектов тестирования немного отвлечемся и подумаем: а что мы должны сделать с паролями пользователя? Хранить их в открытом виде противопоказано, использовать простые методы хеширования вроде md5 без соли - тоже. Так как мы работаем с yii, то рекомендованным методом обеспечения безопасности является применение методов <i>\yii\base\Security</i>.</p>
<p>[code lang="php"]public function testPasswordHashing()<br />
{<br />
   $password = 'test';<br />
   $user = new User(['email' =&gt; 'test@test.test', 'username' =&gt; 'test', 'password' =&gt; $password]);<br />
   $this-&gt;assertTrue(\Yii::$app-&gt;security-&gt;validatePassword($password, $user-&gt;password_hash));<br />
}[/code]</p>
<p>Также обязательно потребуются тесты на попытку задания пустого пароля. Зачем? Просто взгляните на реализацию <em>User::setPassword()</em>. Данная реализация пропускает любые данные в функцию хеширования. В том числе и пустую строку, а это в дальнейшем может негативно отразиться на безопасности приложения.</p>
<p>[code lang="php"]public function testEmptyPassword()<br />
{<br />
   $user = new User(['email' =&gt; 'test@test.test', 'username' =&gt; 'username', 'password' =&gt; '']);<br />
   $this-&gt;assertFalse($user-&gt;validate());<br />
   $this-&gt;assertArrayNotHasKey('username', $user-&gt;getErrors());<br />
   $this-&gt;assertArrayNotHasKey('email', $user-&gt;getErrors());<br />
   $this-&gt;assertArrayHasKey('password_hash', $user-&gt;getErrors());<br />
}</p>
<p>public function testEmptyPasswordDirectSet()<br />
{<br />
   $user = new User(['email' =&gt; 'test@test.test', 'username' =&gt; 'username']);<br />
   $user-&gt;password = '';<br />
   $this-&gt;assertFalse($user-&gt;validate());<br />
   $this-&gt;assertArrayNotHasKey('username', $user-&gt;getErrors());<br />
   $this-&gt;assertArrayNotHasKey('email', $user-&gt;getErrors());<br />
   $this-&gt;assertArrayHasKey('password_hash', $user-&gt;getErrors());<br />
}[/code]</p>
<p>При взгляде не этот код у вас закономерно может возникнуть вопрос о том почему мы устанавливаем свойство password, а проверяем password_hash. Разгадка проста: password - это виртуальное write-only свойство, которое обрабатывается сеттером <em>User::setPassword()</em>, а уже сам этот метод из пароля генерирует хеш. Подробнее можно об это можно прочесть в <a href="http://www.yiiframework.com/doc-2.0/guide-db-active-record.html#data-transformation">руководстве по Yii2</a>.</p>
<p>После запуска тестов мы можем видеть, что ничего не работает как надо. И потребуется поправить правила валидации. Да только обратите внимание на то, что мы не можем устанавливать правила на виртуальные свойства. Поэтому:</p>
<ul>
<li>правило должно быть установлено на свойство <em>password_hash</em></li>
<li>необходимо модифицировать метод <em>setPassword()</em></li>
</ul>
<p>Если на <em>password_hash</em> уже установлено правило <em>required</em>, то метод задания пароля требует модификации.</p>
<p>[code lang="php"]public function setPassword($password)<br />
{<br />
   if ($password) {<br />
       $this-&gt;password_hash = Yii::$app-&gt;security-&gt;generatePasswordHash($password);<br />
   }<br />
}[/code]</p>
<p>В оригинале любая строка (в том числе и пустая) передавалась на вход хеширующей функции. Это вызывало проблемы при задании пустого пароля - на выходе было что-то невразумительное.</p>
<p>После запуска тестов в очередной раз мы видим лишь успешное выполнение.</p>
<p><img class=" size-full wp-image-2096 aligncenter" src="{{ site.baseurl }}/assets/images/2017/05/12-password-validation.png" alt="12-password-validation" width="411" height="196" /></p>
<p>Последнее, что мы хотим покрыть тестами - это корректность сохранения пароля в базу и метод <i>User::validatePassword()</i>.</p>
<p>[code lang="php"]public function testPasswordValidation()<br />
{<br />
   $password = \Yii::$app-&gt;security-&gt;generateRandomString(32);<br />
   $user = new User(['email' =&gt; 'test@test.test', 'username' =&gt; 'test', 'password' =&gt; $password]);<br />
   $this-&gt;assertTrue($user-&gt;validatePassword($password));<br />
}</p>
<p>public function testPasswordValidationAfterSave()<br />
{<br />
   $password = 'SOME_FAKE_PASSWORD';<br />
   $email = 'test@test.test';<br />
   $user = new User(['email' =&gt; $email, 'username' =&gt; 'test', 'password' =&gt; $password]);<br />
   $user-&gt;generateAuthKey();<br />
   $this-&gt;assertTrue($user-&gt;validatePassword($password));<br />
   $user-&gt;save();<br />
   $user2 = User::findByEmail($email);<br />
   $this-&gt;assertTrue($user2-&gt;validatePassword($password));<br />
}[/code]</p>
<p>Последний тест падает с ошибкой. Все потому что мы не реализовали метод <em>User::findByEmail()</em>.</p>
<p>Реализация этого метода будет вашим домашним заданием. После его имплементации вы получите готовый класс пользователя, который был всесторонне проверен тестами.</p>
<p><img class=" size-full wp-image-2099 aligncenter" src="{{ site.baseurl }}/assets/images/2017/05/13-validation-after-save.png" alt="13-validation-after-save" width="454" height="582" /></p>
<h2>Литература</h2>
<ul>
<li><a href="http://www.ozon.ru/context/detail/id/3059177/?partner=russianpenguin&amp;from=bar">"MySQL" Поль Дюбуа, ISBN 5-8459-1119-2</a></li>
<li><a href="http://www.elisdn.ru/blog/78/yii2-codeception-testing">Дмитрий Елисеев: Тестирование с PHPUnit и Codeception в Yii2</a></li>
</ul>
<h2>Исходный код</h2>
<ul>
<li><a href="https://github.com/RussianPenguin/TDD_yii2_app/releases/tag/v0.0.3">Код примеров статьи на GitHub</a></li>
</ul>
<p>&nbsp;</p>
