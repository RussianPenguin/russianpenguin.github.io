---
layout: post
title: 'PHP: Cannot determine default value for internal functions'
date: 2014-10-09 13:43:26.000000000 +04:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- JFF
tags:
- php
meta:
  _wpcom_is_markdown: '1'
  sharing_disabled: '1'
  _wpas_skip_facebook: '1'
  _wpas_skip_google_plus: '1'
  _wpas_skip_twitter: '1'
  _wpas_skip_linkedin: '1'
  _wpas_skip_tumblr: '1'
  _wpas_skip_path: '1'
  _publicize_pending: '1'
  _rest_api_published: '1'
  _rest_api_client_id: "-1"
  _edit_last: '13696577'
author:
  login: russianpenguin
  email: maksim.v.zubkov@gmail.com
  display_name: russianpenguin
  first_name: Maksim
  last_name: Zubkov
permalink: "/2014/10/09/php-cannot-determine-default-value-for-internal-functions/"
---
<p>Зашла речь про небезызвестный htmlspecialchars, но не просто у нем, а о нем и о работе с htmlentities. Если передать в этот метод строку с этими энтитями, то получим двойное перекодирование.</p>
<p>[code lang="php"]echo htmlspecialchars('&amp;quot;текст&amp;quot;');[/code]</p>
<pre>&amp;amp;quot;текст&amp;amp;quot;</pre>
<p>Именно для того, чтобы избежать подобного был добавлен параметр double_encode, который по дефолту всегда true.</p>
<p>Но речь не об этом.</p>
<p>Речь о том, что до этого параметра в спецификации стоит еще два других с дефолтными значениями.</p>
<p>На ум приходит использовать рефлексию для получения дефолтных значений и передачи их в функцию. Но не все так просто.</p>
<p>Сначала напишем код, который будет вызывать функции принимая в качестве параметра ассоциативный массив с онными.</p>
<p>[code lang="php"]function call_user_func_params(callable $func, array $params = array()) {<br />
	if (!is_callable($func)) {<br />
		throw &quot;func is not callable&quot;;<br />
	}<br />
	$reflection = new ReflectionFunction($func);<br />
	$funcParams = array();</p>
<p>	foreach ($reflection-&gt;getParameters() as $parameter) {<br />
		$name = $parameter-&gt;getName();</p>
<p>		if (__DEBUG__) {<br />
			var_dump($parameter-&gt;getName());<br />
			var_dump($parameter-&gt;isOptional());<br />
		}</p>
<p>		if (array_key_exists($name, $params)) {<br />
			array_push($funcParams, $params[$name]);<br />
		} elseif ($parameter-&gt;isOptional()) {<br />
			array_push($funcParams, $parameter-&gt;getDefaultValue());<br />
		} else {<br />
			throw new Exception(&quot;Value for parameter {$name} not found&quot;);<br />
		}<br />
	}<br />
	return call_user_func_array($func, $funcParams);<br />
}[/code]</p>
<p>А теперь воспользуемся ей.</p>
<p>[code lang="php"]function foo($bar = 'bar', $baz = 'baz') {<br />
	echo &quot;{$bar}, {$baz}\n&quot;;<br />
}</p>
<p>call_user_func_params('foo', array('baz' =&gt; 'xyz'));[/code]</p>
<p>Выводит то, что и ожидалось.</p>
<pre>bar, xyz</pre>
<p>А теперь так.</p>
<p>[code lang="php"]call_user_func_params('htmlspecialchars', array('string' =&gt; &quot;&amp;quot;текст&amp;quot;&quot;, 'double_encode' =&gt; false));[/code]</p>
<p>Облом-с.</p>
<pre>PHP Fatal error:  Uncaught exception 'ReflectionException' with message 'Cannot determine default value for internal functions' in file.php</pre>
<p>А все потому, что пхп обрабатывает встроенные функции иначе, нежели написанные кривыми руками программиста. :)</p>
<p>А еще документация нас открыто уведомляет о том, что именя параметров реальные (я про встроенные функции) могут отличаться от того, что написано в спецификации.</p>
