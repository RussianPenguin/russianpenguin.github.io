---
layout: post
title: Python 3+ и окончания строк в файлах
date: 2015-02-17 23:53:18.000000000 +03:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Обработка текста
- Разработка
tags:
- python
meta:
  _wpcom_is_markdown: '1'
  _publicize_pending: '1'
  sharing_disabled: '1'
  _rest_api_published: '1'
  _rest_api_client_id: "-1"
  _wpas_skip_facebook: '1'
  _wpas_skip_google_plus: '1'
  _wpas_skip_twitter: '1'
  _wpas_skip_linkedin: '1'
  _wpas_skip_tumblr: '1'
  _wpas_skip_path: '1'
author:
  login: russianpenguin
  email: maksim.v.zubkov@gmail.com
  display_name: russianpenguin
  first_name: Maksim
  last_name: Zubkov
permalink: "/2015/02/17/python-3-%d0%b8-%d0%be%d0%ba%d0%be%d0%bd%d1%87%d0%b0%d0%bd%d0%b8%d1%8f-%d1%81%d1%82%d1%80%d0%be%d0%ba-%d0%b2-%d1%84%d0%b0%d0%b9%d0%bb%d0%b0%d1%85/"
---
<p>Столкнулся одного теста, который был перенесен с python 2+ на python 3+.</p>
<p>Тест делал следующее:</p>
<p>скачивал файл через python.requests и сравнивал его с эталонным содержимым на диске (посимвольно).</p>
<p>Выглядело приблизительно так</p>
<p>[code language="python"]import requests<br />
import sys<br />
response = requests.get(sys.argv[1])<br />
if response.code == 200:<br />
  with open(sys.argv[2]) as f:<br />
    from_storage = f.read()<br />
    from_web = response.text<br />
    assert from_web == from_storage[/code]</p>
<p>Да. Все верно. Этот тест не проходил.</p>
<p>И тут была замечена одна странность: файл на диске содержал последовательность crlf, а в coдержимом from_storage этой последовательности не оказало.</p>
<p>А дело все в том, что в python 3+ было введено <a title="Python 3+ - open function" href="https://docs.python.org/release/3.2/library/functions.html#open">соглашение</a> на обработку символов перевода строки. И управление работой осуществляется манипулированием параметром newline.</p>
<ul>
<li>On input, if newline is None, universal newlines mode is enabled. Lines in the input can end in '\n', '\r', or '\r\n', and these are translated into '\n' before being returned to the caller. If it is &#039;&#039;, universal newline mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.</li>
<li>On output, if newline is None, any '\n' characters written are translated to the system default line separator, os.linesep. If newline is &#039;&#039;, no translation takes place. If newline is any of the other legal values, any '\n' characters written are translated to the given string.</li>
</ul>
<p>В итоге достаточно было указать newline=&#039;&#039; как CRLF появились.</p>
